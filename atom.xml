<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sylvia</title>
  
  <subtitle>Viva La Vida</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://janvia.github.io/"/>
  <updated>2019-05-12T05:53:19.000Z</updated>
  <id>https://janvia.github.io/</id>
  
  <author>
    <name>sylvia</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://janvia.github.io/2024/11/08/source/"/>
    <id>https://janvia.github.io/2024/11/08/source/</id>
    <published>2024-11-08T11:45:24.330Z</published>
    <updated>2019-05-12T05:53:19.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="计算机视觉"><a href="#计算机视觉" class="headerlink" title="计算机视觉"></a>计算机视觉</h3><blockquote><ul><li><p>Stanford Vision Lab - <a href="http://vision.stanford.edu" target="_blank" rel="noopener">http://vision.stanford.edu</a></p></li><li><p>CS 131 Computer Vision: Foundations and Applications - <a href="http://vision.stanford.edu/teaching/cs131_fall1617/index.html" target="_blank" rel="noopener">http://vision.stanford.edu/teaching/cs131_fall1617/index.html</a></p></li><li><p>CS231n: Convolutional Neural Networks for Visual Recognition - <a href="http://cs231n.stanford.edu" target="_blank" rel="noopener">http://cs231n.stanford.edu</a></p></li><li><p>CS231A: Computer Vision, From 3D Reconstruction to Recognition - <a href="http://web.stanford.edu/class/cs231a/" target="_blank" rel="noopener">http://web.stanford.edu/class/cs231a/</a></p></li><li><p>Computer Vision: A Modern Approach - <a href="http://cmuems.com/excap/readings/forsyth-ponce-computer-vision-a-modern-approach.pdf" target="_blank" rel="noopener">http://cmuems.com/excap/readings/forsyth-ponce-computer-vision-a-modern-approach.pdf</a></p></li><li><p>Computer Vision: Algorithms and Applications - <a href="http://szeliski.org/Book/drafts/SzeliskiBook_20100903_draft.pdf" target="_blank" rel="noopener">http://szeliski.org/Book/drafts/SzeliskiBook_20100903_draft.pdf</a></p></li><li><p>Computer Vision: Models, Learning, and Inference - <a href="http://www.computervisionmodels.com/" target="_blank" rel="noopener">http://www.computervisionmodels.com/</a></p></li></ul></blockquote><h3 id="自然语言处理"><a href="#自然语言处理" class="headerlink" title="自然语言处理"></a>自然语言处理</h3><blockquote><ul><li><p>CS224n: Natural Language Processing with Deep Learning - <a href="http://web.stanford.edu/class/cs224n/" target="_blank" rel="noopener">http://web.stanford.edu/class/cs224n/</a></p></li><li><p>Natural Language Processing with Python - <a href="http://www.nltk.org/book/（视频：https://www.youtube.com/playlist?list=PLQVvvaa0QuDf2JswnfiGkliBInZnIC4HL）" target="_blank" rel="noopener">http://www.nltk.org/book/（视频：https://www.youtube.com/playlist?list=PLQVvvaa0QuDf2JswnfiGkliBInZnIC4HL）</a></p></li><li><p>《自然语言处理综论》英文版 - <a href="https://web.stanford.edu/~jurafsky/slp3/" target="_blank" rel="noopener">https://web.stanford.edu/~jurafsky/slp3/</a></p></li><li><p>《统计自然语言处理》</p></li><li><p>《Python 自然语言处理》</p></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;计算机视觉&quot;&gt;&lt;a href=&quot;#计算机视觉&quot; class=&quot;headerlink&quot; title=&quot;计算机视觉&quot;&gt;&lt;/a&gt;计算机视觉&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Stanford Vision Lab - &lt;a href=&quot;http:
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>rust 多平台demo</title>
    <link href="https://janvia.github.io/2022/08/20/rust%20%E5%A4%9A%E5%B9%B3%E5%8F%B0demo/"/>
    <id>https://janvia.github.io/2022/08/20/rust 多平台demo/</id>
    <published>2022-08-20T08:55:59.000Z</published>
    <updated>2025-04-11T02:58:04.750Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="rust-多平台demo"><a href="#rust-多平台demo" class="headerlink" title="rust 多平台demo"></a>rust 多平台demo</h3><h4 id="rust-安装"><a href="#rust-安装" class="headerlink" title="rust 安装"></a>rust 安装</h4><p>官网：<a href="https://rustup.rs/" target="_blank" rel="noopener">https://rustup.rs/</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl --proto &apos;=https&apos; --tlsv1.2 -sSf https://sh.rustup.rs | sh</span><br></pre></td></tr></table></figure><p>提高init速度</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> RUSTUP_DIST_SERVER=<span class="string">"https://mirrors.ustc.edu.cn/rust-static"</span></span><br><span class="line"><span class="built_in">export</span> RUSTUP_UPDATE_ROOT=<span class="string">"https://mirrors.ustc.edu.cn/rust-static/rustup"</span></span><br></pre></td></tr></table></figure><h5 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h5><p>编辑<code>$HOME/.cargo/config.toml</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[source.crates-io]</span><br><span class="line">replace-with = &quot;ustc&quot;</span><br><span class="line"></span><br><span class="line">[source.ustc]</span><br><span class="line">registry = &quot;sparse+https://mirrors.ustc.edu.cn/crates.io-index/&quot;</span><br><span class="line">#更多---------------------------</span><br><span class="line">[source.crates-io]</span><br><span class="line">registry = &quot;https://github.com/rust-lang/crates.io-index&quot;</span><br><span class="line"># 指定镜像</span><br><span class="line">replace-with = &apos;ustc&apos;</span><br><span class="line"></span><br><span class="line"># 清华大学</span><br><span class="line">[source.tuna]</span><br><span class="line">registry = &quot;https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git&quot;</span><br><span class="line"></span><br><span class="line"># 中国科学技术大学</span><br><span class="line">[source.ustc]</span><br><span class="line">registry = &quot;https://mirrors.ustc.edu.cn/crates.io-index&quot;</span><br><span class="line"></span><br><span class="line"># 上海交通大学</span><br><span class="line">[source.sjtu]</span><br><span class="line">registry = &quot;https://mirrors.sjtug.sjtu.edu.cn/git/crates.io-index&quot;</span><br><span class="line"></span><br><span class="line"># rustcc社区</span><br><span class="line">[source.rustcc]</span><br><span class="line">registry = &quot;https://code.aliyun.com/rustcc/crates.io-index.git&quot;</span><br></pre></td></tr></table></figure><p>vscode配置</p><p>check commond : check 改为 clippy ，以防止rust_analyzer卡</p><h5 id="版本切换"><a href="#版本切换" class="headerlink" title="版本切换"></a>版本切换</h5><p>在使用SIMD进行加速时，需要使用nightly版本</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rustup update nightly</span><br><span class="line">rustup override set nightly</span><br></pre></td></tr></table></figure><p>查看是否配置成功</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rustc --version</span><br></pre></td></tr></table></figure><p>输出：rustc 1.84.0-nightly (798fb83f7 2024-10-16)</p><p>如果想要所有 cargo build 命令都不显示警告，可以在当前终端会话里设置环境变量：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export RUSTFLAGS=&quot;-Awarnings&quot;</span><br><span class="line">cargo build</span><br></pre></td></tr></table></figure><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><h5 id="第一步：创建Rust库"><a href="#第一步：创建Rust库" class="headerlink" title="第一步：创建Rust库"></a>第一步：创建Rust库</h5><ol><li><p><strong>新建Rust库项目</strong>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cargo new rust_tokenizer --lib</span><br><span class="line">cd rust_tokenizer</span><br></pre></td></tr></table></figure></li><li><p><strong>编辑<code>Cargo.toml</code></strong>： 添加如下内容，以确保生成动态链接库：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[lib]</span><br><span class="line">name = &quot;rust_tokenizer&quot;</span><br><span class="line">crate-type = [&quot;cdylib&quot;]</span><br></pre></td></tr></table></figure></li><li><p><strong>编写Rust代码</strong>： 在<code>src/lib.rs</code>中添加你的tokenizer逻辑，同时提供一个C兼容的接口。下面是一个简单的例子，使用Rust实现一个基础的tokenizer函数。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use std::ffi::&#123;CString, CStr&#125;;</span><br><span class="line">use std::os::raw::c_char;</span><br><span class="line"></span><br><span class="line">#[no_mangle]</span><br><span class="line">pub extern &quot;C&quot; fn tokenize(text: *const c_char) -&gt; *mut c_char &#123;</span><br><span class="line">    let c_str = unsafe &#123;</span><br><span class="line">        assert!(!text.is_null());</span><br><span class="line">        CStr::from_ptr(text)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    let r_str = c_str.to_str().unwrap();</span><br><span class="line">    let tokenized = r_str.replace(&quot; &quot;, &quot;|&quot;);  // 简单的tokenization逻辑</span><br><span class="line"></span><br><span class="line">    CString::new(tokenized).unwrap().into_raw()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[no_mangle]</span><br><span class="line">pub extern &quot;C&quot; fn free_string(s: *mut c_char) &#123;</span><br><span class="line">    unsafe &#123;</span><br><span class="line">        if s.is_null() &#123; return &#125;</span><br><span class="line">        CString::from_raw(s)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们定义了两个函数：<code>tokenize</code>用于处理字符串，<code>free_string</code>用于释放Rust分配的内存。</p></li><li><p><strong>编译Rust代码</strong>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cargo build --release</span><br></pre></td></tr></table></figure><p>编译后的<code>.so</code>文件位于<code>target/release</code>目录下。</p></li></ol><h5 id="第二步：在C-中调用Rust函数"><a href="#第二步：在C-中调用Rust函数" class="headerlink" title="第二步：在C++中调用Rust函数"></a>第二步：在C++中调用Rust函数</h5><ol><li><p><strong>编写C++代码</strong>： 在C++项目中，使用Rust编译出的<code>.so</code>库文件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">    char* tokenize(const char* text);</span><br><span class="line">    void free_string(char* s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    const char* text = &quot;Hello, world!&quot;;</span><br><span class="line">    char* result = tokenize(text);</span><br><span class="line">    std::cout &lt;&lt; &quot;Tokenized: &quot; &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    free_string(result);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>编译C++代码</strong>： 使用g++编译，并链接Rust生成的<code>.so</code>文件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">g++ -o tokenizer_test main.cpp -L/path/to/target/release -lrust_tokenizer -ldl</span><br></pre></td></tr></table></figure></li><li><p><strong>运行C++程序</strong>： 确保Rust生成的<code>.so</code>文件路径在LD_LIBRARY_PATH环境变量中，或者复制到合适的位置。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=/path/to/target/release:$LD_LIBRARY_PATH</span><br><span class="line">./tokenizer_test</span><br></pre></td></tr></table></figure></li></ol><h4 id="C-交叉编译"><a href="#C-交叉编译" class="headerlink" title="C++ 交叉编译"></a>C++ 交叉编译</h4><h5 id="1-rust配置"><a href="#1-rust配置" class="headerlink" title="1.rust配置"></a>1.rust配置</h5><p>添加目标架构 <code>aarch64-unknown-linux-gnu</code>（适用于 ARM64 的 Linux）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rustup target add aarch64-unknown-linux-gnu</span><br></pre></td></tr></table></figure><h5 id="2-安装交叉编译工具链"><a href="#2-安装交叉编译工具链" class="headerlink" title="2. 安装交叉编译工具链"></a>2. 安装交叉编译工具链</h5><p>需要一个交叉编译工具链来生成适用于 ARM64 架构的二进制文件。在 Debian/Ubuntu 上，可以安装以下工具：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install gcc-aarch64-linux-gnu</span><br></pre></td></tr></table></figure><h5 id="3-配置和编译"><a href="#3-配置和编译" class="headerlink" title="3. 配置和编译"></a>3. 配置和编译</h5><p>在项目的根目录下创建一个文件 <code>.cargo/config.toml</code>，以配置交叉编译工具链：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[target.aarch64-unknown-linux-gnu]</span><br><span class="line">ar = &quot;aarch64-linux-gnu-ar&quot;</span><br><span class="line">linker = &quot;aarch64-linux-gnu-gcc&quot;</span><br></pre></td></tr></table></figure><p>接下来，运行以下命令进行编译：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cargo build --release --target=aarch64-unknown-linux-gnu</span><br></pre></td></tr></table></figure><p>编译完成后， <code>.so</code> 文件将在 <code>target/aarch64-unknown-linux-gnu/release/</code> 目录下。</p><h5 id="4-使用自定义工具链"><a href="#4-使用自定义工具链" class="headerlink" title="4.使用自定义工具链"></a>4.使用自定义工具链</h5><p>在项目的根目录下创建 <code>.cargo/config.toml</code> 文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[target.aarch64-unknown-linux-gnu]</span><br><span class="line">ar = &quot;/path/to/custom/toolchain/bin/aarch64-linux-gnu-ar&quot;</span><br><span class="line">linker = &quot;/path/to/custom/toolchain/bin/aarch64-linux-gnu-gcc&quot;</span><br></pre></td></tr></table></figure><p>设置环境变量以指定工具链的 sysroot 和相关库路径：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=/path/to/custom/toolchain/bin/aarch64-linux-gnu-gcc</span><br><span class="line">export CC_aarch64_unknown_linux_gnu=/path/to/custom/toolchain/bin/aarch64-linux-gnu-gcc</span><br><span class="line">export AR_aarch64_unknown_linux_gnu=/path/to/custom/toolchain/bin/aarch64-linux-gnu-ar</span><br></pre></td></tr></table></figure><h5 id="5-编译x64通用"><a href="#5-编译x64通用" class="headerlink" title="5.编译x64通用"></a>5.编译x64通用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rustup target add x86_64-unknown-linux-gnu</span><br></pre></td></tr></table></figure><p>在 Rust 项目中，创建一个适用于更广泛兼容性的 <code>.cargo/config.toml</code> 文件，确保使用的是一个较低版本的 glibc，并且静态链接标准库和其他依赖项：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[target.x86_64-unknown-linux-gnu]</span><br><span class="line">rustflags = [</span><br><span class="line">  &quot;-C&quot;, &quot;target-feature=+crt-static&quot;,</span><br><span class="line">  &quot;-C&quot;, &quot;link-args=-Wl,--no-as-needed -Wl,--as-needed&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>确保在编译时使用目标为 <code>x86_64-unknown-linux-gnu</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cargo build --release --target=x86_64-unknown-linux-gnu</span><br></pre></td></tr></table></figure><h4 id="编译ubuntu16-04兼容的python库"><a href="#编译ubuntu16-04兼容的python库" class="headerlink" title="编译ubuntu16.04兼容的python库"></a>编译ubuntu16.04兼容的python库</h4><h5 id="docker-安装"><a href="#docker-安装" class="headerlink" title="docker 安装"></a>docker 安装</h5><p><a href="https://docs.docker.com/desktop/wsl/#download" target="_blank" rel="noopener">https://docs.docker.com/desktop/wsl/#download</a></p><h5 id="拉取docker"><a href="#拉取docker" class="headerlink" title="拉取docker"></a>拉取docker</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull ubuntu:16.04</span><br><span class="line">docker run -it \</span><br><span class="line">  --name ubuntu16-rust3 \</span><br><span class="line">  --net=host \</span><br><span class="line">  -v /home/jw/.cargo:/root/.cargo \</span><br><span class="line">  -v /home/jw:/home/jw \</span><br><span class="line">  -v /mnt/c/share:/mnt/c/share \</span><br><span class="line">  ubuntu:16.04</span><br><span class="line">apt-get update</span><br><span class="line">apt-get install -y curl build-essential</span><br><span class="line">apt-get install libhdf5-dev</span><br><span class="line">apt-get install -y g++-7</span><br><span class="line">update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-7 90</span><br></pre></td></tr></table></figure><p>配置rust</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl https://sh.rustup.rs -sSf | sh</span><br><span class="line">source $HOME/.cargo/env #root</span><br></pre></td></tr></table></figure><p>配置Python</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /home/jw</span><br><span class="line">bin/micromamba shell init --shell bash --root-prefix=./micromamba</span><br><span class="line">source ~/.bashrc</span><br><span class="line">micromamba activate [env_name]</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd code/</span><br><span class="line">maturin build --release --out dist</span><br></pre></td></tr></table></figure><p>无法安装问题解决：将xxx-0.1.0-cp310-cp310-manylinux_2_24_x86_64.whl更名为xxx-0.1.0-cp310-cp310-manylinux1_x86_64.whl</p><h5 id="重启后重新进入"><a href="#重启后重新进入" class="headerlink" title="重启后重新进入"></a>重启后重新进入</h5><p>进入环境</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps </span><br><span class="line">docker exec -it ubuntu16-rust3 /bin/bash</span><br></pre></td></tr></table></figure><p>激活python环境</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">micromamba activate [env_name]</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd code/</span><br><span class="line">maturin build --release --out dist</span><br></pre></td></tr></table></figure><h5 id="编译manylinux2014"><a href="#编译manylinux2014" class="headerlink" title="编译manylinux2014"></a>编译manylinux2014</h5><p>拉取<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull quay.io/pypa/manylinux2014_x86_64</span><br></pre></td></tr></table></figure></p><p>创建<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images</span><br><span class="line"></span><br><span class="line">sudo docker run -it \</span><br><span class="line">  --name manylinux2014 \</span><br><span class="line">  --net=host \</span><br><span class="line">  -v /home/jw:/home/jw \</span><br><span class="line">  -v code:/code \</span><br><span class="line">  quay.io/pypa/manylinux2014_x86_64</span><br></pre></td></tr></table></figure></p><p>配置环境<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y curl &amp;&amp; \</span><br><span class="line">curl --proto &apos;=https&apos; --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y &amp;&amp; \</span><br><span class="line">source $HOME/.cargo/env</span><br><span class="line">yum groupinstall -y &quot;Development Tools&quot;</span><br><span class="line">yum install -y hdf5 hdf5-devel</span><br></pre></td></tr></table></figure></p><p>配置Python</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /home/jw</span><br><span class="line">bin/micromamba shell init --shell bash --root-prefix=./micromamba</span><br><span class="line">source ~/.bashrc</span><br><span class="line">micromamba activate [env_name]</span><br></pre></td></tr></table></figure><p>编译<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd code/rust</span><br><span class="line">maturin build --release --manylinux=2014 --out dist</span><br></pre></td></tr></table></figure></p><h5 id="编译windows的python库"><a href="#编译windows的python库" class="headerlink" title="编译windows的python库"></a>编译windows的python库</h5><p>1.安装rust环境<br>进入官网<a href="https://rustup.rs/，点击display" target="_blank" rel="noopener">https://rustup.rs/，点击display</a> all supported installers，下载rust-init.exe，然后双击安装，全部默认安装<br>2.换源加速<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$env:RUSTUP_DIST_SERVER=&quot;https://mirrors.ustc.edu.cn/rust-static&quot;</span><br><span class="line">$env:RUSTUP_UPDATE_ROOT=&quot;https://mirrors.ustc.edu.cn/rust-static/rustup&quot;</span><br></pre></td></tr></table></figure></p><p>编辑<code>C:/Users/jiangwei/.cargo/config.toml</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[source.crates-io]</span><br><span class="line">replace-with = &quot;ustc&quot;</span><br><span class="line"></span><br><span class="line">[source.ustc]</span><br><span class="line">registry = &quot;sparse+https://mirrors.ustc.edu.cn/crates.io-index/&quot;</span><br></pre></td></tr></table></figure><p>3.conda配置<br>因为发现rust默认的环境在powershell,而conda在cmd，所以需要在Powershell配置conda<br>在搜索栏搜索powershell ，右击选择管理员模式打开<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set-ExecutionPolicy RemoteSigned</span><br></pre></td></tr></table></figure></p><p>重启powershell<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda init powershell</span><br></pre></td></tr></table></figure></p><p>如果还有问题，配置环境变量<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E:\miniconda3</span><br><span class="line">E:\miniconda3\Scripts</span><br><span class="line">E:\miniconda3\Library\bin（某些情况下需要）</span><br></pre></td></tr></table></figure></p><h4 id="c-和python接口应用实例"><a href="#c-和python接口应用实例" class="headerlink" title="c++和python接口应用实例"></a>c++和python接口应用实例</h4><h5 id="1-配置-Cargo-toml"><a href="#1-配置-Cargo-toml" class="headerlink" title="1. 配置 Cargo.toml"></a>1. 配置 <code>Cargo.toml</code></h5><p>首先，在Rust 项目的 <code>Cargo.toml</code> 文件中添加 <code>pyo3</code> 和 <code>maturin</code> 依赖：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[package]</span><br><span class="line">name = &quot;tokenizers_wrapper&quot;</span><br><span class="line">version = &quot;0.1.0&quot;</span><br><span class="line">edition = &quot;2018&quot;</span><br><span class="line"></span><br><span class="line">[dependencies]</span><br><span class="line">pyo3 = &#123; version = &quot;0.15&quot;, features = [&quot;extension-module&quot;] &#125;</span><br><span class="line">serde_json = &quot;1.0&quot;</span><br><span class="line">tokenizers = &quot;0.13&quot;</span><br><span class="line"></span><br><span class="line">[lib]</span><br><span class="line">crate-type = [&quot;cdylib&quot;]</span><br><span class="line"></span><br><span class="line">[package.metadata.maturin]</span><br><span class="line">name = &quot;tokenizers_wrapper&quot;</span><br></pre></td></tr></table></figure><p>pyo3和<code>maturin</code>用于python接口,cdylib用于c++接口</p><h5 id="2-编写-Rust-代码"><a href="#2-编写-Rust-代码" class="headerlink" title="2. 编写 Rust 代码"></a>2. 编写 Rust 代码</h5><p>在 <code>src/lib.rs</code> 中编写 Rust 代码，将现有功能同时暴露给 Python 和 C++：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use pyo3::prelude::*;</span><br><span class="line">use serde_json::Value;</span><br><span class="line">use std::&#123;collections::HashMap, str::FromStr&#125;;</span><br><span class="line">use tokenizers::models::bpe::BPE;</span><br><span class="line">use tokenizers::pre_tokenizers::byte_level::ByteLevel;</span><br><span class="line">use tokenizers::tokenizer::Tokenizer;</span><br><span class="line"></span><br><span class="line">#[pyclass]</span><br><span class="line">pub struct TokenizerWrapper &#123;</span><br><span class="line">    tokenizer: Tokenizer,</span><br><span class="line">    decode_str: String,</span><br><span class="line">    id_to_token_result: String,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[pymethods]</span><br><span class="line">impl TokenizerWrapper &#123;</span><br><span class="line">    #[new]</span><br><span class="line">    pub fn from_str(json: &amp;str) -&gt; Self &#123;</span><br><span class="line">        TokenizerWrapper &#123;</span><br><span class="line">            tokenizer: Tokenizer::from_str(json).unwrap(),</span><br><span class="line">            decode_str: String::new(),</span><br><span class="line">            id_to_token_result: String::new(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #[staticmethod]</span><br><span class="line">    pub fn byte_level_bpe_from_str(vocab: &amp;str, merges: &amp;str, added_tokens: &amp;str) -&gt; Self &#123;</span><br><span class="line">        let vocab_json: Value = serde_json::from_str(vocab).unwrap();</span><br><span class="line">        let added_tokens_json: Value = serde_json::from_str(added_tokens).unwrap();</span><br><span class="line">        let mut vocab = HashMap::new();</span><br><span class="line"></span><br><span class="line">        match vocab_json &#123;</span><br><span class="line">            Value::Object(m) =&gt; &#123;</span><br><span class="line">                for (token, id) in m &#123;</span><br><span class="line">                    if let Value::Number(id) = id &#123;</span><br><span class="line">                        let id = id.as_u64().unwrap() as u32;</span><br><span class="line">                        vocab.insert(token, id);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            _ =&gt; panic!(&quot;Invalid vocab.json file.&quot;),</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        match added_tokens_json &#123;</span><br><span class="line">            Value::Object(m) =&gt; &#123;</span><br><span class="line">                for (token, id) in m &#123;</span><br><span class="line">                    if let Value::Number(id) = id &#123;</span><br><span class="line">                        let id = id.as_u64().unwrap() as u32;</span><br><span class="line">                        vocab.insert(token, id);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            _ =&gt; panic!(&quot;Invalid added_tokens.json file.&quot;),</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let merges = merges</span><br><span class="line">            .lines()</span><br><span class="line">            .filter(|line| !line.starts_with(&quot;#version&quot;))</span><br><span class="line">            .map(|line| &#123;</span><br><span class="line">                let parts = line.split(&apos; &apos;).collect::&lt;Vec&lt;_&gt;&gt;();</span><br><span class="line">                if parts.len() != 2 &#123;</span><br><span class="line">                    panic!(&quot;Invalid merges.txt file.&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">                (parts[0].to_string(), parts[1].to_string())</span><br><span class="line">            &#125;)</span><br><span class="line">            .collect::&lt;Vec&lt;(String, String)&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        let byte_level = ByteLevel::new(</span><br><span class="line">            /*add_prefix_space=*/ false, /*trim_offsets=*/ false,</span><br><span class="line">            /*use_regex=*/ false,</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        let mut tokenizer = Tokenizer::new(BPE::new(vocab, merges));</span><br><span class="line">        tokenizer.with_pre_tokenizer(byte_level).with_decoder(byte_level);</span><br><span class="line"></span><br><span class="line">        TokenizerWrapper &#123;</span><br><span class="line">            tokenizer,</span><br><span class="line">            decode_str: String::new(),</span><br><span class="line">            id_to_token_result: String::new(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pub fn encode(&amp;mut self, text: &amp;str, add_special_tokens: bool) -&gt; Vec&lt;u32&gt; &#123;</span><br><span class="line">        let encoded = self.tokenizer.encode(text, add_special_tokens).unwrap();</span><br><span class="line">        encoded.get_ids().to_vec()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pub fn encode_batch(&amp;mut self, texts: Vec&lt;&amp;str&gt;, add_special_tokens: bool) -&gt; Vec&lt;Vec&lt;u32&gt;&gt; &#123;</span><br><span class="line">        self.tokenizer</span><br><span class="line">            .encode_batch(texts, add_special_tokens)</span><br><span class="line">            .unwrap()</span><br><span class="line">            .into_iter()</span><br><span class="line">            .map(|encoded| encoded.get_ids().to_vec())</span><br><span class="line">            .collect()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pub fn decode(&amp;mut self, ids: Vec&lt;u32&gt;, skip_special_tokens: bool) -&gt; String &#123;</span><br><span class="line">        self.tokenizer.decode(ids.as_slice(), skip_special_tokens).unwrap()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pub fn get_vocab_size(&amp;self) -&gt; usize &#123;</span><br><span class="line">        self.tokenizer.get_vocab_size(true)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pub fn id_to_token(&amp;mut self, id: u32) -&gt; String &#123;</span><br><span class="line">        match self.tokenizer.id_to_token(id) &#123;</span><br><span class="line">            Some(token) =&gt; token,</span><br><span class="line">            None =&gt; String::new(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pub fn token_to_id(&amp;self, token: &amp;str) -&gt; Option&lt;u32&gt; &#123;</span><br><span class="line">        self.tokenizer.token_to_id(token)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[pymodule]</span><br><span class="line">fn tokenizers_wrapper(_py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; &#123;</span><br><span class="line">    m.add_class::&lt;TokenizerWrapper&gt;()?;</span><br><span class="line">    Ok(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// C++ FFI functions</span><br><span class="line">#[no_mangle]</span><br><span class="line">pub extern &quot;C&quot; fn tokenizers_new_from_str(input_cstr: *const u8, len: usize) -&gt; *mut TokenizerWrapper &#123;</span><br><span class="line">    let json = unsafe &#123; std::str::from_utf8(std::slice::from_raw_parts(input_cstr, len)).unwrap() &#125;;</span><br><span class="line">    Box::into_raw(Box::new(TokenizerWrapper::from_str(json)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[no_mangle]</span><br><span class="line">pub extern &quot;C&quot; fn byte_level_bpe_tokenizers_new_from_str(</span><br><span class="line">    input_vocab_str: *const u8,</span><br><span class="line">    len_vocab: usize,</span><br><span class="line">    input_merges_str: *const u8,</span><br><span class="line">    len_merges: usize,</span><br><span class="line">    input_added_tokens_str: *const u8,</span><br><span class="line">    len_added_tokens: usize,</span><br><span class="line">) -&gt; *mut TokenizerWrapper &#123;</span><br><span class="line">    let vocab = unsafe &#123; std::str::from_utf8(std::slice::from_raw_parts(input_vocab_str, len_vocab)).unwrap() &#125;;</span><br><span class="line">    let merges = unsafe &#123; std::str::from_utf8(std::slice::from_raw_parts(input_merges_str, len_merges)).unwrap() &#125;;</span><br><span class="line">    let added_tokens = unsafe &#123; std::str::from_utf8(std::slice::from_raw_parts(input_added_tokens_str, len_added_tokens)).unwrap() &#125;;</span><br><span class="line">    Box::into_raw(Box::new(TokenizerWrapper::byte_level_bpe_from_str(vocab, merges, added_tokens)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[no_mangle]</span><br><span class="line">pub extern &quot;C&quot; fn tokenizers_encode(</span><br><span class="line">    handle: *mut TokenizerWrapper,</span><br><span class="line">    input_cstr: *const u8,</span><br><span class="line">    len: usize,</span><br><span class="line">    add_special_tokens: i32,</span><br><span class="line">    out_result: *mut TokenizerEncodeResult,</span><br><span class="line">) &#123;</span><br><span class="line">    let input_data = unsafe &#123; std::str::from_utf8(std::slice::from_raw_parts(input_cstr, len)).unwrap() &#125;;</span><br><span class="line">    let encoded = unsafe &#123; &amp;mut *handle &#125;.encode(input_data, add_special_tokens != 0);</span><br><span class="line">    let len = encoded.len();</span><br><span class="line">    unsafe &#123;</span><br><span class="line">        *out_result = TokenizerEncodeResult &#123;</span><br><span class="line">            token_ids: Box::into_raw(encoded.into_boxed_slice()) as *mut u32,</span><br><span class="line">            len,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[no_mangle]</span><br><span class="line">pub extern &quot;C&quot; fn tokenizers_encode_batch(</span><br><span class="line">    handle: *mut TokenizerWrapper,</span><br><span class="line">    input_cstr: *const *const u8,</span><br><span class="line">    input_len: *const usize,</span><br><span class="line">    num_seqs: usize,</span><br><span class="line">    add_special_tokens: i32,</span><br><span class="line">    out_result: *mut TokenizerEncodeResult,</span><br><span class="line">) &#123;</span><br><span class="line">    let input_data = (0..num_seqs)</span><br><span class="line">        .map(|i| &#123;</span><br><span class="line">            unsafe &#123;</span><br><span class="line">                std::str::from_utf8(std::slice::from_raw_parts(*input_cstr.offset(i as isize), *input_len.offset(i as isize))).unwrap()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .collect::&lt;Vec&lt;&amp;str&gt;&gt;();</span><br><span class="line">    let encoded_batch = unsafe &#123; &amp;mut *handle &#125;.encode_batch(input_data, add_special_tokens != 0);</span><br><span class="line">    for (i, encoded) in encoded_batch.into_iter().enumerate() &#123;</span><br><span class="line">        let len = encoded.len();</span><br><span class="line">        unsafe &#123;</span><br><span class="line">            *out_result.offset(i as isize) = TokenizerEncodeResult &#123;</span><br><span class="line">                token_ids: Box::into_raw(encoded.into_boxed_slice()) as *mut u32,</span><br><span class="line">                len,</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[no_mangle]</span><br><span class="line">pub extern &quot;C&quot; fn tokenizers_free_encode_results(results: *mut TokenizerEncodeResult, num_seqs: usize) &#123;</span><br><span class="line">    let slice = unsafe &#123; std::slice::from_raw_parts_mut(results, num_seqs) &#125;;</span><br><span class="line">    for result in slice &#123;</span><br><span class="line">        unsafe &#123;</span><br><span class="line">            drop(Box::from_raw(std::slice::from_raw_parts_mut(result.token_ids, result.len)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[no_mangle]</span><br><span class="line">pub extern &quot;C&quot; fn tokenizers_decode(</span><br><span class="line">    handle: *mut TokenizerWrapper,</span><br><span class="line">    input_ids: *const u32,</span><br><span class="line">    len: usize,</span><br><span class="line">    skip_special_tokens: i32,</span><br><span class="line">) &#123;</span><br><span class="line">    let input_data = unsafe &#123; std::slice::from_raw_parts(input_ids, len) &#125;;</span><br><span class="line">    unsafe &#123; &amp;mut *handle &#125;.decode(input_data.to_vec(), skip_special_tokens != 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[no_mangle]</span><br><span class="line">pub extern &quot;C&quot; fn tokenizers_get_decode_str(</span><br><span class="line">    handle: *mut TokenizerWrapper,</span><br><span class="line">    out_cstr: *mut *mut u8,</span><br><span class="line">    out_len: *mut usize,</span><br><span class="line">) &#123;</span><br><span class="line">    let decode_str = unsafe &#123; &amp;mut *handle &#125;.decode_str.as_bytes();</span><br><span class="line">    unsafe &#123;</span><br><span class="line">        *out_cstr = decode_str.as_ptr() as *mut u8;</span><br><span class="line">        *out_len = decode_str.len();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[no_mangle]</span><br><span class="line">pub extern &quot;C&quot; fn tokenizers_free(wrapper: *mut TokenizerWrapper) &#123;</span><br><span class="line">    unsafe &#123;</span><br><span class="line">        drop(Box::from_raw(wrapper));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[no_mangle]</span><br><span class="line">pub extern &quot;C&quot; fn tokenizers_get_vocab_size(handle: *mut TokenizerWrapper, size: *mut usize) &#123;</span><br><span class="line">    unsafe &#123;</span><br><span class="line">        *size = (*handle).get_vocab_size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[no_mangle]</span><br><span class="line">pub extern &quot;C&quot; fn tokenizers_id_to_token(</span><br><span class="line">    handle: *mut TokenizerWrapper,</span><br><span class="line">    id: u32,</span><br><span class="line">    out_cstr: *mut *mut u8,</span><br><span class="line">    out_len: *mut usize,</span><br><span class="line">) &#123;</span><br><span class="line">    let token = unsafe &#123; &amp;mut *handle &#125;.id_to_token(id).into_bytes();</span><br><span class="line">    unsafe &#123;</span><br><span class="line">        *out_cstr = token.as_ptr() as *mut u8;</span><br><span class="line">        *out_len = token.len();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[no_mangle]</span><br><span class="line">pub extern &quot;C&quot; fn tokenizers_token_to_id(</span><br><span class="line">    handle: *mut TokenizerWrapper,</span><br><span class="line">    token: *const u8,</span><br><span class="line">    len: usize,</span><br><span class="line">    out_id: *mut i32,</span><br><span class="line">) &#123;</span><br><span class="line">    let token_str = unsafe &#123; std::str::from_utf8(std::slice::from_raw_parts(token, len)).unwrap() &#125;;</span><br><span class="line">    let id = unsafe &#123; &amp;mut *handle &#125;.token_to_id(token_str);</span><br><span class="line">    unsafe &#123;</span><br><span class="line">        *out_id = match id &#123;</span><br><span class="line">            Some(id) =&gt; id as i32,</span><br><span class="line">            None =&gt; -1,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[repr(C)]</span><br><span class="line">pub struct TokenizerEncodeResult &#123;</span><br><span class="line">    token_ids: *mut u32,</span><br><span class="line">    len: usize,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-构建和发布"><a href="#3-构建和发布" class="headerlink" title="3. 构建和发布"></a>3. 构建和发布</h5><p>使用 <code>maturin</code> 来构建和发布 Python 包。确保安装了 <code>maturin</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install maturin</span><br></pre></td></tr></table></figure><p>在项目根目录下运行以下命令来构建 Python 包：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">maturin develop --release</span><br></pre></td></tr></table></figure><p>这将构建并安装 Rust 扩展模块，使其可以在 Python 中导入和使用。</p><p>错误解决：pkg_config 错误</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install pkg-config</span><br></pre></td></tr></table></figure><p>错误解决：ssl 错误</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install libssl-dev</span><br></pre></td></tr></table></figure><h5 id="4-编写-Python-接口"><a href="#4-编写-Python-接口" class="headerlink" title="4. 编写 Python 接口"></a>4. 编写 Python 接口</h5><p>现在，可以在 Python 中导入并使用这个包装器模块。以下是一个简单的 Python 接口示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import tokenizers_wrapper</span><br><span class="line"></span><br><span class="line"># 从字符串创建 TokenizerWrapper 实例</span><br><span class="line">json_str = &apos;...&apos;  # 你的 tokenizer JSON 字符串</span><br><span class="line">tokenizer = tokenizers_wrapper.TokenizerWrapper(json_str)</span><br><span class="line"></span><br><span class="line"># 使用 byte-level BPE 创建 TokenizerWrapper 实例</span><br><span class="line">vocab = &apos;...&apos;  # 你的 vocab.json 字符串</span><br><span class="line">merges = &apos;...&apos;  # 你的 merges.txt 字符串</span><br><span class="line">added_tokens = &apos;...&apos;  # 你的 added_tokens.json 字符串</span><br><span class="line">tokenizer = tokenizers_wrapper.TokenizerWrapper.byte_level_bpe_from_str(vocab, merges, added_tokens)</span><br><span class="line"></span><br><span class="line"># 编码单个文本</span><br><span class="line">text = &quot;Hello, world!&quot;</span><br><span class="line">token_ids = tokenizer.encode(text, add_special_tokens=True)</span><br><span class="line">print(token_ids)</span><br><span class="line"></span><br><span class="line"># 批量编码文本</span><br><span class="line">texts = [&quot;Hello, world!&quot;, &quot;Goodbye, world!&quot;]</span><br><span class="line">batch_token_ids = tokenizer.encode_batch(texts, add_special_tokens=True)</span><br><span class="line">print(batch_token_ids)</span><br><span class="line"></span><br><span class="line"># 解码 token IDs</span><br><span class="line">decoded_text = tokenizer.decode(token_ids, skip_special_tokens=True)</span><br><span class="line">print(decoded_text)</span><br><span class="line"></span><br><span class="line"># 获取词汇表大小</span><br><span class="line">vocab_size = tokenizer.get_vocab_size()</span><br><span class="line">print(vocab_size)</span><br><span class="line"></span><br><span class="line"># 从 token ID 获取 token</span><br><span class="line">token = tokenizer.id_to_token(0)</span><br><span class="line">print(token)</span><br><span class="line"></span><br><span class="line"># 从 token 获取 token ID</span><br><span class="line">token_id = tokenizer.token_to_id(&quot;Hello&quot;)</span><br><span class="line">print(token_id)</span><br></pre></td></tr></table></figure><h5 id="5-编写-C-接口"><a href="#5-编写-C-接口" class="headerlink" title="5. 编写 C++ 接口"></a>5. 编写 C++ 接口</h5><p>创建一个简单的 C++ 项目来使用这个包装器模块：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &quot;tokenizers_wrapper.h&quot;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    const char* json_str = R&quot;(&#123;&quot;type&quot;: &quot;bpe&quot;, &quot;unk_token&quot;: &quot;[UNK]&quot;&#125;)&quot;;</span><br><span class="line">    TokenizerWrapper* tokenizer = tokenizers_new_from_str((const uint8_t*)json_str, strlen(json_str));</span><br><span class="line"></span><br><span class="line">    const char* text = &quot;Hello, world!&quot;;</span><br><span class="line">    TokenizerEncodeResult result;</span><br><span class="line">    tokenizers_encode(tokenizer, (const uint8_t*)text, strlen(text), 1, &amp;result);</span><br><span class="line"></span><br><span class="line">    std::vector&lt;uint32_t&gt; token_ids(result.token_ids, result.token_ids + result.len);</span><br><span class="line">    for (uint32_t id : token_ids) &#123;</span><br><span class="line">        std::cout &lt;&lt; id &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    tokenizers_free_encode_results(&amp;result, 1);</span><br><span class="line">    tokenizers_free(tokenizer);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-构建和运行-C-项目"><a href="#6-构建和运行-C-项目" class="headerlink" title="6. 构建和运行 C++ 项目"></a>6. 构建和运行 C++ 项目</h5><p>创建一个 <code>CMakeLists.txt</code> 文件来构建 C++ 项目：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.18)</span><br><span class="line">project(tokenizers_cpp CXX)</span><br><span class="line"></span><br><span class="line">set(CMAKE_CXX_STANDARD 17)</span><br><span class="line">set(CMAKE_CXX_STANDARD_REQUIRED ON)</span><br><span class="line"></span><br><span class="line">add_executable(tokenizers_demo main.cpp)</span><br><span class="line"></span><br><span class="line"># 设置 Tokenizers Wrapper 库的路径</span><br><span class="line">set(TOKENIZERS_WRAPPER_LIB_PATH &quot;/path/to/your/rust/library&quot;)</span><br><span class="line">include_directories($&#123;TOKENIZERS_WRAPPER_LIB_PATH&#125;/include)</span><br><span class="line">link_directories($&#123;TOKENIZERS_WRAPPER_LIB_PATH&#125;/lib)</span><br><span class="line"></span><br><span class="line"># 链接 Tokenizers Wrapper 库</span><br><span class="line">target_link_libraries(tokenizers_demo tokenizers_wrapper)</span><br></pre></td></tr></table></figure><p>然后，使用 CMake 构建和运行项目：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">./tokenizers_demo</span><br></pre></td></tr></table></figure><h4 id="rust调用c"><a href="#rust调用c" class="headerlink" title="rust调用c++"></a>rust调用c++</h4><p>编写mnn_adapter.cpp并编译成so文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extern &quot;C&quot; &#123; </span><br><span class="line">    int add(int a, int b) &#123; return a + b; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -fPIC -shared mnn_adapter.cpp -o libmnn_adapter.so</span><br></pre></td></tr></table></figure><p>编写build.rs</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extern crate dunce;</span><br><span class="line">use std::&#123;env, path::PathBuf&#125;;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line"></span><br><span class="line">    let root_v = PathBuf::from(env::var_os(&quot;CARGO_MANIFEST_DIR&quot;).unwrap());</span><br><span class="line">    let library_dir_v = dunce::canonicalize(root_v.join(&quot;variable&quot;)).unwrap();</span><br><span class="line"></span><br><span class="line">    //库文件路径，与静态链接的区别是没有加库名称</span><br><span class="line">    println!(&quot;cargo:rustc-link-search=native=&#123;&#125;&quot;, env::join_paths(&amp;[library_dir_v]).unwrap().to_str().unwrap());</span><br><span class="line">    println!(&quot;cargo:rustc-link-lib=dylib=mnn_adapter&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写main.rs</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#![allow(non_snake_case)]</span><br><span class="line">#[link(name=&quot;mnn_adapter&quot;)]</span><br><span class="line">extern &quot;C&quot; &#123; fn add(x: i32, y: i32) -&gt; i32; &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">fn main() &#123;</span><br><span class="line">    // println!(&quot;Hello, world!&quot;);</span><br><span class="line">    let x = unsafe &#123; add(62, 30)&#125;;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, x); // 92</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写cargo.yml</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[package]</span><br><span class="line">name = &quot;rust_demo&quot;</span><br><span class="line">version = &quot;0.1.0&quot;</span><br><span class="line">edition = &quot;2018&quot;</span><br><span class="line"></span><br><span class="line">[dependencies]</span><br><span class="line">libc = &quot;0.2&quot;</span><br><span class="line"></span><br><span class="line">[build_dependencies]</span><br><span class="line">dunce = &quot;1.0.0&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=./variable</span><br><span class="line">cargo run</span><br></pre></td></tr></table></figure><h4 id="MNN示例"><a href="#MNN示例" class="headerlink" title="MNN示例"></a>MNN示例</h4><p>build.rs</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extern crate dunce;</span><br><span class="line">extern crate bindgen;</span><br><span class="line">use std::&#123;env, path::PathBuf&#125;;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line"></span><br><span class="line">    let root_v = PathBuf::from(env::var_os(&quot;CARGO_MANIFEST_DIR&quot;).unwrap());</span><br><span class="line">    let library_dir_v = dunce::canonicalize(root_v.join(&quot;variable&quot;)).unwrap();</span><br><span class="line">    </span><br><span class="line">    // 编译 C++ 文件并生成静态库</span><br><span class="line">    cc::Build::new()</span><br><span class="line">        .cpp(true)</span><br><span class="line">        .include(&quot;/home/jw/code/rust_condition_se/condition_se/third_party/mnn/mnn-linux-x64-2.9.0/include&quot;) // 指定 MNN 的头文件路径</span><br><span class="line">        .flag_if_supported(&quot;-std=c++14&quot;) // 设置 C++ 标准</span><br><span class="line">        .file(&quot;variable/mnn_adapter.cpp&quot;)</span><br><span class="line">        .compile(&quot;mnn_adapter&quot;); // 生成 libmnn_adapter.a 静态库</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //库文件路径，与静态链接的区别是没有加库名称</span><br><span class="line">    println!(&quot;cargo:rustc-link-search=native=&#123;&#125;&quot;, env::join_paths(&amp;[library_dir_v]).unwrap().to_str().unwrap());</span><br><span class="line">    println!(&quot;cargo:rustc-link-lib=dylib=mnn_adapter&quot;);</span><br><span class="line">     // 指定 MNN 的库文件路径</span><br><span class="line">     println!(&quot;cargo:rustc-link-search=native=/home/jw/code/rust_condition_se/condition_se/third_party/mnn/mnn-linux-x64-2.9.0/lib&quot;);</span><br><span class="line">     println!(&quot;cargo:rustc-link-lib=dylib=MNN&quot;);</span><br><span class="line"></span><br><span class="line">      // 链接 C++ 标准库</span><br><span class="line">    println!(&quot;cargo:rustc-link-lib=stdc++&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>wapper.h</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;MNN/Interpreter.hpp&quot;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; &#123; </span><br><span class="line"></span><br><span class="line">    using namespace MNN;</span><br><span class="line"></span><br><span class="line">    struct MNN_Interpreter &#123;</span><br><span class="line">        std::shared_ptr&lt;Interpreter&gt; interpreter;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    struct MNN_Session &#123;</span><br><span class="line">        Session* session;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    struct MNN_Tensor &#123;</span><br><span class="line">        Tensor* tensor;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    MNN_Interpreter* MNN_Interpreter_create(const char* model_path);</span><br><span class="line">    MNN_Session* MNN_Interpreter_createSession(MNN_Interpreter* interpreter);</span><br><span class="line">    MNN_Tensor* MNN_Interpreter_getSessionInput(MNN_Interpreter* interpreter, MNN_Session* session);</span><br><span class="line">    void MNN_Tensor_setData(MNN_Tensor* tensor, float* data, int size);</span><br><span class="line">    void MNN_Interpreter_runSession(MNN_Interpreter* interpreter, MNN_Session* session);</span><br><span class="line">    MNN_Tensor* MNN_Interpreter_getSessionOutput(MNN_Interpreter* interpreter, MNN_Session* session);</span><br><span class="line">    void MNN_Tensor_getData(MNN_Tensor* tensor, float* data, int size);</span><br><span class="line">    void MNN_Interpreter_destroy(MNN_Interpreter* interpreter);</span><br><span class="line">    void MNN_Session_destroy(MNN_Session* session);</span><br><span class="line">    void MNN_Tensor_destroy(MNN_Tensor* tensor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mnn_adapter.cpp</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;wrapper.h&quot;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line"></span><br><span class="line">MNN_Interpreter* MNN_Interpreter_create(const char* model_path) &#123;</span><br><span class="line">    MNN_Interpreter* mnn_interpreter = new MNN_Interpreter;</span><br><span class="line">    mnn_interpreter-&gt;interpreter = std::shared_ptr&lt;MNN::Interpreter&gt;(MNN::Interpreter::createFromFile(model_path));</span><br><span class="line">    return mnn_interpreter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 其他函数定义保持不变</span><br><span class="line">MNN_Session* MNN_Interpreter_createSession(MNN_Interpreter* interpreter) &#123;</span><br><span class="line">    MNN_Session* mnn_session = new MNN_Session;</span><br><span class="line">    MNN::ScheduleConfig config;</span><br><span class="line">    mnn_session-&gt;session = interpreter-&gt;interpreter-&gt;createSession(config);</span><br><span class="line">    return mnn_session;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MNN_Tensor* MNN_Interpreter_getSessionInput(MNN_Interpreter* interpreter, MNN_Session* session) &#123;</span><br><span class="line">    MNN_Tensor* mnn_tensor = new MNN_Tensor;</span><br><span class="line">    mnn_tensor-&gt;tensor = interpreter-&gt;interpreter-&gt;getSessionInput(session-&gt;session, nullptr);</span><br><span class="line">    return mnn_tensor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MNN_Tensor_setData(MNN_Tensor* tensor, float* data, int size) &#123;</span><br><span class="line">    std::memcpy(tensor-&gt;tensor-&gt;host&lt;float&gt;(), data, size * sizeof(float));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MNN_Interpreter_runSession(MNN_Interpreter* interpreter, MNN_Session* session) &#123;</span><br><span class="line">    interpreter-&gt;interpreter-&gt;runSession(session-&gt;session);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MNN_Tensor* MNN_Interpreter_getSessionOutput(MNN_Interpreter* interpreter, MNN_Session* session) &#123;</span><br><span class="line">    MNN_Tensor* mnn_tensor = new MNN_Tensor;</span><br><span class="line">    mnn_tensor-&gt;tensor = interpreter-&gt;interpreter-&gt;getSessionOutput(session-&gt;session, nullptr);</span><br><span class="line">    return mnn_tensor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MNN_Tensor_getData(MNN_Tensor* tensor, float* data, int size) &#123;</span><br><span class="line">    std::memcpy(data, tensor-&gt;tensor-&gt;host&lt;float&gt;(), size * sizeof(float));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MNN_Interpreter_destroy(MNN_Interpreter* interpreter) &#123;</span><br><span class="line">    delete interpreter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MNN_Session_destroy(MNN_Session* session) &#123;</span><br><span class="line">    delete session;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MNN_Tensor_destroy(MNN_Tensor* tensor) &#123;</span><br><span class="line">    delete tensor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lib.rs</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#![allow(non_snake_case)]</span><br><span class="line"></span><br><span class="line">extern crate libc;</span><br><span class="line">use libc::c_char;</span><br><span class="line">use std::ffi::CString;</span><br><span class="line">use std::ptr;</span><br><span class="line"></span><br><span class="line">#[repr(C)]</span><br><span class="line">pub struct MNN_Interpreter &#123;</span><br><span class="line">    _private: [u8; 0],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[repr(C)]</span><br><span class="line">pub struct MNN_Session &#123;</span><br><span class="line">    _private: [u8; 0],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[repr(C)]</span><br><span class="line">pub struct MNN_Tensor &#123;</span><br><span class="line">    _private: [u8; 0],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[link(name = &quot;mnn_adapter&quot;)]</span><br><span class="line">#[link(name = &quot;MNN&quot;)]</span><br><span class="line">#[link(name = &quot;stdc++&quot;)]</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">    fn MNN_Interpreter_create(model_path: *const c_char) -&gt; *mut MNN_Interpreter;</span><br><span class="line">    fn MNN_Interpreter_createSession(interpreter: *mut MNN_Interpreter) -&gt; *mut MNN_Session;</span><br><span class="line">    fn MNN_Interpreter_getSessionInput(interpreter: *mut MNN_Interpreter, session: *mut MNN_Session) -&gt; *mut MNN_Tensor;</span><br><span class="line">    fn MNN_Tensor_setData(tensor: *mut MNN_Tensor, data: *const f32, size: i32);</span><br><span class="line">    fn MNN_Interpreter_runSession(interpreter: *mut MNN_Interpreter, session: *mut MNN_Session);</span><br><span class="line">    fn MNN_Interpreter_getSessionOutput(interpreter: *mut MNN_Interpreter, session: *mut MNN_Session) -&gt; *mut MNN_Tensor;</span><br><span class="line">    fn MNN_Tensor_getData(tensor: *mut MNN_Tensor, data: *mut f32, size: i32);</span><br><span class="line">    fn MNN_Interpreter_destroy(interpreter: *mut MNN_Interpreter);</span><br><span class="line">    fn MNN_Session_destroy(session: *mut MNN_Session);</span><br><span class="line">    fn MNN_Tensor_destroy(tensor: *mut MNN_Tensor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub struct Interpreter &#123;</span><br><span class="line">    interpreter: *mut MNN_Interpreter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Interpreter &#123;</span><br><span class="line">    pub fn create(model_path: &amp;str) -&gt; Result&lt;Self, &amp;&apos;static str&gt; &#123;</span><br><span class="line">        let c_model_path = CString::new(model_path).map_err(|_| &quot;Failed to create CString&quot;)?;</span><br><span class="line">        let interpreter = unsafe &#123; MNN_Interpreter_create(c_model_path.as_ptr() as *const c_char) &#125;;</span><br><span class="line">        if interpreter.is_null() &#123;</span><br><span class="line">            Err(&quot;Failed to create MNN Interpreter&quot;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Ok(Self &#123; interpreter &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pub fn create_session(&amp;self) -&gt; Result&lt;Session, &amp;&apos;static str&gt; &#123;</span><br><span class="line">        let session = unsafe &#123; MNN_Interpreter_createSession(self.interpreter) &#125;;</span><br><span class="line">        if session.is_null() &#123;</span><br><span class="line">            Err(&quot;Failed to create session&quot;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Ok(Session &#123; session &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pub fn run_session(&amp;self, session: &amp;Session) &#123;</span><br><span class="line">        unsafe &#123;</span><br><span class="line">            MNN_Interpreter_runSession(self.interpreter, session.session);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Drop for Interpreter &#123;</span><br><span class="line">    fn drop(&amp;mut self) &#123;</span><br><span class="line">        if !self.interpreter.is_null() &#123;</span><br><span class="line">            unsafe &#123;</span><br><span class="line">                MNN_Interpreter_destroy(self.interpreter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub struct Session &#123;</span><br><span class="line">    session: *mut MNN_Session,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Session &#123;</span><br><span class="line">    pub fn get_input(&amp;self, interpreter: &amp;Interpreter) -&gt; Result&lt;Tensor, &amp;&apos;static str&gt; &#123;</span><br><span class="line">        let tensor = unsafe &#123; MNN_Interpreter_getSessionInput(interpreter.interpreter, self.session) &#125;;</span><br><span class="line">        if tensor.is_null() &#123;</span><br><span class="line">            Err(&quot;Failed to get input tensor&quot;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Ok(Tensor &#123; tensor &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pub fn get_output(&amp;self, interpreter: &amp;Interpreter) -&gt; Result&lt;Tensor, &amp;&apos;static str&gt; &#123;</span><br><span class="line">        let tensor = unsafe &#123; MNN_Interpreter_getSessionOutput(interpreter.interpreter, self.session) &#125;;</span><br><span class="line">        if tensor.is_null() &#123;</span><br><span class="line">            Err(&quot;Failed to get output tensor&quot;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Ok(Tensor &#123; tensor &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Drop for Session &#123;</span><br><span class="line">    fn drop(&amp;mut self) &#123;</span><br><span class="line">        if !self.session.is_null() &#123;</span><br><span class="line">            unsafe &#123;</span><br><span class="line">                MNN_Session_destroy(self.session);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub struct Tensor &#123;</span><br><span class="line">    tensor: *mut MNN_Tensor,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Tensor &#123;</span><br><span class="line">    pub fn set_data(&amp;self, data: &amp;[f32]) &#123;</span><br><span class="line">        unsafe &#123;</span><br><span class="line">            MNN_Tensor_setData(self.tensor, data.as_ptr(), data.len() as i32);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pub fn get_data(&amp;self, data: &amp;mut [f32]) &#123;</span><br><span class="line">        unsafe &#123;</span><br><span class="line">            MNN_Tensor_getData(self.tensor, data.as_mut_ptr(), data.len() as i32);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Drop for Tensor &#123;</span><br><span class="line">    fn drop(&amp;mut self) &#123;</span><br><span class="line">        if !self.tensor.is_null() &#123;</span><br><span class="line">            unsafe &#123;</span><br><span class="line">                MNN_Tensor_destroy(self.tensor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.rs</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extern crate rust_demo;</span><br><span class="line"></span><br><span class="line">use rust_demo::&#123;Interpreter, Tensor&#125;;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let model_path = &quot;/home/jw/code/rust_condition_se/condition_se/libri_aishell2_fsd50k_NAMFmid1D_160_lsnr1_l1100_wsdr_mspec_nokl_lag7_l1noise_1111_flim_mf_emb512_1dec/model_se.mnn&quot;;</span><br><span class="line">    match Interpreter::create(model_path) &#123;</span><br><span class="line">        Ok(interpreter) =&gt; &#123;</span><br><span class="line">            match interpreter.create_session() &#123;</span><br><span class="line">                Ok(session) =&gt; &#123;</span><br><span class="line">                    match session.get_input(&amp;interpreter) &#123;</span><br><span class="line">                        Ok(input_tensor) =&gt; &#123;</span><br><span class="line">                            let input_data = vec![0.0f32; 1 * 3 * 224 * 224]; // 假设输入是 1x3x224x224 的图像</span><br><span class="line">                            input_tensor.set_data(&amp;input_data);</span><br><span class="line"></span><br><span class="line">                            interpreter.run_session(&amp;session);</span><br><span class="line"></span><br><span class="line">                            match session.get_output(&amp;interpreter) &#123;</span><br><span class="line">                                Ok(output_tensor) =&gt; &#123;</span><br><span class="line">                                    let mut output_data = vec![0.0f32; 1000]; // 假设输出大小为 1000</span><br><span class="line">                                    output_tensor.get_data(&amp;mut output_data);</span><br><span class="line"></span><br><span class="line">                                    println!(&quot;Output data: &#123;:?&#125;&quot;, &amp;output_data[..10]);</span><br><span class="line">                                &#125;</span><br><span class="line">                                Err(err) =&gt; eprintln!(&quot;Error getting output tensor: &#123;&#125;&quot;, err),</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        Err(err) =&gt; eprintln!(&quot;Error getting input tensor: &#123;&#125;&quot;, err),</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                Err(err) =&gt; eprintln!(&quot;Error creating session: &#123;&#125;&quot;, err),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Err(err) =&gt; eprintln!(&quot;Error: &#123;&#125;&quot;, err),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="c-调用rust"><a href="#c-调用rust" class="headerlink" title="c++调用rust"></a>c++调用rust</h4><p>cbindgen自动生成header文件</p><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cargo install cbindgen</span><br></pre></td></tr></table></figure><h5 id="编写cbindgen-toml"><a href="#编写cbindgen-toml" class="headerlink" title="编写cbindgen.toml"></a>编写cbindgen.toml</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">header = &quot;// SPDX-License-Identifier: MIT OR Apache-2.0&quot;</span><br><span class="line">sys_includes = [&quot;stddef.h&quot;, &quot;stdint.h&quot;, &quot;stdlib.h&quot;]</span><br><span class="line">no_includes = true</span><br><span class="line">include_version = true</span><br><span class="line">include_guard = &quot;CONDITION_SE_H&quot;</span><br><span class="line">tab_width = 4</span><br><span class="line">style = &quot;Type&quot;</span><br><span class="line">language = &quot;C&quot;</span><br><span class="line">cpp_compat = true</span><br></pre></td></tr></table></figure><p>在cargo.toml中添加(后面测试好像不用加)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[package.metadata.capi.header]</span><br><span class="line">name = &quot;condition_se&quot;</span><br><span class="line">subdirectory = &quot;condition_se&quot;</span><br><span class="line">[package.metadata.capi.pkg_config]</span><br><span class="line">name = &quot;libconditionse&quot;</span><br><span class="line">filename = &quot;conditionse&quot;</span><br><span class="line">[package.metadata.capi.library]</span><br><span class="line">name = &quot;conditionse&quot;</span><br></pre></td></tr></table></figure><h5 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cbindgen --config cbindgen.toml --crate condition_se --output ../src/condition_se_cc.h</span><br></pre></td></tr></table></figure><p>出现问题跨项目类型依赖时，无法导出NoiseType</p><p>在cbindgen.toml中添加</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[parse]</span><br><span class="line"># Enable parsing of dependencies</span><br><span class="line">parse_deps = true</span><br><span class="line"></span><br><span class="line"># List items to include in the bindings</span><br><span class="line">include = [&quot;NoiseType&quot;]</span><br><span class="line"></span><br><span class="line">[parse.expand]</span><br><span class="line"># Enable all features if necessary</span><br><span class="line">features = [&quot;all&quot;]</span><br><span class="line"></span><br><span class="line">[export]</span><br><span class="line"># Ensure NoiseType and TestEnum are exported correctly</span><br><span class="line">include = [&quot;NoiseType&quot;]</span><br></pre></td></tr></table></figure><h4 id="rust-运行bin"><a href="#rust-运行bin" class="headerlink" title="rust 运行bin"></a>rust 运行bin</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cargo run --bin aec --release</span><br></pre></td></tr></table></figure><p>使用feature</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cargo run --bin aec --release --features=&quot;aec bin&quot;</span><br></pre></td></tr></table></figure><h4 id="rust的jupyter"><a href="#rust的jupyter" class="headerlink" title="rust的jupyter"></a>rust的jupyter</h4><p>为了便于进行算法模块测试，使用jupyter更方便</p><h5 id="安装jupyter-lab"><a href="#安装jupyter-lab" class="headerlink" title="安装jupyter lab"></a>安装jupyter lab</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda install -c conda-forge jupyterlab</span><br><span class="line">#plotly 用于渲染可视化图表</span><br><span class="line">jupyter labextension install jupyterlab-plotly</span><br><span class="line">#更换主题</span><br><span class="line">jupyter labextension install @shahinrostami/theme-purple-please</span><br></pre></td></tr></table></figure><h5 id="安装-evcxr"><a href="#安装-evcxr" class="headerlink" title="安装 evcxr"></a>安装 evcxr</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cargo install evcxr_jupyter</span><br><span class="line">evcxr_jupyter --install</span><br></pre></td></tr></table></figure><h5 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#导入</span><br><span class="line">:timing</span><br><span class="line">:dep &#123; rand = &quot;0.7.3&quot; &#125;</span><br><span class="line">:dep &#123; log = &quot;0.4.11&quot; &#125;</span><br><span class="line">:dep my_crate = &#123; path = &quot;.&quot; &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let values = (1..13).map(fib).collect::&lt;Vec&lt;i32&gt;&gt;();</span><br><span class="line">values</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">显示所有变量</span><br><span class="line">:vars</span><br></pre></td></tr></table></figure><p>自定义显示</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use std::fmt::Debug;</span><br><span class="line">pub struct Matrix&lt;T&gt; &#123;pub values: Vec&lt;T&gt;, pub row_size: usize&#125;</span><br><span class="line">impl&lt;T: Debug&gt; Matrix&lt;T&gt; &#123;</span><br><span class="line">    pub fn evcxr_display(&amp;self) &#123;</span><br><span class="line">        let mut html = String::new();</span><br><span class="line">        html.push_str(&quot;&lt;table&gt;&quot;);</span><br><span class="line">        for r in 0..(self.values.len() / self.row_size) &#123;</span><br><span class="line">            html.push_str(&quot;&lt;tr&gt;&quot;);</span><br><span class="line">            for c in 0..self.row_size &#123;</span><br><span class="line">                html.push_str(&quot;&lt;td&gt;&quot;);</span><br><span class="line">                html.push_str(&amp;format!(&quot;&#123;:?&#125;&quot;, self.values[r * self.row_size + c]));</span><br><span class="line">                html.push_str(&quot;&lt;/td&gt;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            html.push_str(&quot;&lt;/tr&gt;&quot;);            </span><br><span class="line">        &#125;</span><br><span class="line">        html.push_str(&quot;&lt;/table&gt;&quot;);</span><br><span class="line">        println!(&quot;EVCXR_BEGIN_CONTENT text/html\n&#123;&#125;\nEVCXR_END_CONTENT&quot;, html);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let m = Matrix &#123;values: vec![1,2,3,4,5,6,7,8,9], row_size: 3&#125;;</span><br><span class="line">m</span><br></pre></td></tr></table></figure><p>显示图片</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:dep image = &quot;0.23&quot;</span><br><span class="line">:dep evcxr_image = &quot;1.1&quot;</span><br><span class="line">use evcxr_image::ImageDisplay;</span><br><span class="line"></span><br><span class="line">image::ImageBuffer::from_fn(256, 256, |x, y| &#123;</span><br><span class="line">    if (x as i32 - y as i32).abs() &lt; 3 &#123;</span><br><span class="line">        image::Rgb([0, 0, 255])</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        image::Rgb([0, 0, 0])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="配置jupyter-lab代码补全（vscode更好用）"><a href="#配置jupyter-lab代码补全（vscode更好用）" class="headerlink" title="配置jupyter lab代码补全（vscode更好用）"></a>配置jupyter lab代码补全（vscode更好用）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 安装jupyterlab-lsp</span><br><span class="line">pip install jupyter-lsp</span><br><span class="line"> </span><br><span class="line"># 安装python-lsp-server</span><br><span class="line">pip install python-lsp-server</span><br></pre></td></tr></table></figure><p>设置</p><p>依次点击Settings—&gt;Settings Editor—&gt;Code Completion(第二个)—&gt;打开Enable autocompletion</p><h4 id="无法编译，无法启动"><a href="#无法编译，无法启动" class="headerlink" title="无法编译，无法启动"></a>无法编译，无法启动</h4><p>通常是因为环境有冲突，与其找原因不如直接删除缓存，重新编译</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rm -r ~/.cargo/registry/</span><br></pre></td></tr></table></figure><h5 id="hdf5编译出错"><a href="#hdf5编译出错" class="headerlink" title="hdf5编译出错"></a>hdf5编译出错</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt install libhdf5-dev</span><br></pre></td></tr></table></figure><h5 id="ort-的rocm模式"><a href="#ort-的rocm模式" class="headerlink" title="ort 的rocm模式"></a>ort 的rocm模式</h5><p>重装rocm</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Uninstall single-version ROCm packages</span><br><span class="line">sudo apt autoremove rocm-core</span><br><span class="line"> </span><br><span class="line"># Uninstall Kernel-mode Driver</span><br><span class="line">sudo apt autoremove amdgpu-dkms</span><br><span class="line"> </span><br><span class="line"># remove apt source</span><br><span class="line">sudo rm /etc/apt/sources.list.d/&lt;rocm_repository-name&gt;.list</span><br><span class="line">sudo rm /etc/apt/sources.list.d/&lt;amdgpu_repository-name&gt;.list</span><br><span class="line">sudo rm /etc/apt/sources.list.d/rocm.list</span><br><span class="line">sudo rm /etc/apt/sources.list.d/amdgpu.list</span><br><span class="line"> </span><br><span class="line">sudo rm -rf /var/cache/apt/*</span><br><span class="line">sudo apt-get clean all</span><br><span class="line"> </span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><p>安装参考rocm环境配置，可以安装6.0.2</p><p>编译onnxruntime</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ONNXRUNTIME_REPO=https://github.com/Microsoft/onnxruntime</span><br><span class="line">ONNXRUNTIME_BRANCH=main</span><br><span class="line">git clone --single-branch --branch $&#123;ONNXRUNTIME_BRANCH&#125; --recursive $&#123;ONNXRUNTIME_REPO&#125; onnxruntime &amp;&amp;\</span><br><span class="line">    cd onnxruntime &amp;&amp;\</span><br><span class="line">    /bin/sh ./build.sh --config Release --build_shared_lib --parallel --cmake_extra_defines\</span><br><span class="line">            ONNXRUNTIME_VERSION=$(cat ./VERSION_NUMBER) --use_rocm --rocm_home=/opt/rocm</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;rust-多平台demo&quot;&gt;&lt;a href=&quot;#rust-多平台demo&quot; class=&quot;headerlink&quot; title=&quot;rust 多平台demo&quot;&gt;&lt;/a&gt;rust 多平台demo&lt;/h3&gt;&lt;h4 id=&quot;rust-安装
      
    
    </summary>
    
      <category term="深度学习移植" scheme="https://janvia.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%A7%BB%E6%A4%8D/"/>
    
    
      <category term="rust 多平台demo" scheme="https://janvia.github.io/tags/rust-%E5%A4%9A%E5%B9%B3%E5%8F%B0demo/"/>
    
  </entry>
  
  <entry>
    <title>sacred</title>
    <link href="https://janvia.github.io/2022/08/20/sacred/"/>
    <id>https://janvia.github.io/2022/08/20/sacred/</id>
    <published>2022-08-20T08:55:59.000Z</published>
    <updated>2024-04-25T06:29:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Sacred-安装"><a href="#Sacred-安装" class="headerlink" title="Sacred 安装"></a>Sacred 安装</h3><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 主角</span><br><span class="line">pip install sacred</span><br><span class="line"></span><br><span class="line"># 用于数据库连接</span><br><span class="line">pip install numpy pymongo</span><br></pre></td></tr></table></figure><h4 id="MongoDB-安装"><a href="#MongoDB-安装" class="headerlink" title="MongoDB 安装"></a>MongoDB 安装</h4><p>MongoDB 是一个数据库管理系统，这里用作 Sacred 的存储后端。</p><p>在 ubuntu 上的 MongoDB 安装可以参考 <a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-ubuntu/" target="_blank" rel="noopener">Install MongoDB Community Edition on Ubuntu</a>，其他系统也可以在该网站上找到对应的安装方式。</p><h4 id="mongoDB-常用命令"><a href="#mongoDB-常用命令" class="headerlink" title="mongoDB 常用命令"></a>mongoDB 常用命令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 启动</span><br><span class="line">sudo service mongod start</span><br><span class="line"></span><br><span class="line"># 停止</span><br><span class="line">sudo service mongod stop</span><br><span class="line"></span><br><span class="line"># 重启</span><br><span class="line">sudo service mongod restart</span><br><span class="line"></span><br><span class="line"># 进入MongoDB</span><br><span class="line">mongosh</span><br></pre></td></tr></table></figure><p>创建一个名为 sacred 的数据库，用作 sacred 工具的后端存储：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 进入MongoDB</span><br><span class="line">mongosh</span><br><span class="line"></span><br><span class="line"># 创建sacred数据库。use命令切换数据库，没有该数据就会自动创建一个</span><br><span class="line">use sacred</span><br></pre></td></tr></table></figure><h2 id="Omniboard安装"><a href="#Omniboard安装" class="headerlink" title="Omniboard安装"></a>Omniboard安装</h2><p>在 Ubuntu 机器上安装版本≥v8 的 Node.js，系统默认 apt 安装的版本不够，需要手动安装</p><h4 id="安装node-js和npm"><a href="#安装node-js和npm" class="headerlink" title="安装node.js和npm"></a>安装node.js和npm</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install nodejs</span><br><span class="line">sudo apt install npm</span><br></pre></td></tr></table></figure><p>新版本安装(hexo不支持)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash - &amp;&amp;\</span><br><span class="line">sudo apt-get install -y nodejs</span><br></pre></td></tr></table></figure><p>nvm指定版本安装</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxychains4 wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | proxychains4 bash</span><br><span class="line">source ~/.zshrc</span><br><span class="line">export NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node/</span><br><span class="line">export NVM_IOJS_ORG_MIRROR=http://npm.taobao.org/mirrors/iojs</span><br><span class="line">nvm install 12.16.2</span><br><span class="line">nvm use 12.16.2</span><br></pre></td></tr></table></figure><p>换源</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo npm install -g nrm</span><br><span class="line">nrm ls</span><br><span class="line">nrm use taobao</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 4. 测试安装版本信息</span><br><span class="line">node -v</span><br><span class="line">npm version</span><br><span class="line">npx -v</span><br></pre></td></tr></table></figure><p>第二步，npm 安装 omniboard</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g omniboard</span><br></pre></td></tr></table></figure><p>第三步，开启 omniboard 服务。平时也是用该命令开启 omniboard 可视化前端</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 开启用法</span><br><span class="line">omniboard -m hostname:port:database</span><br><span class="line"></span><br><span class="line"># 默认情况下如下，其中27017是MongoDB的端口</span><br><span class="line">omniboard -m localhost:27017:sacred</span><br></pre></td></tr></table></figure><p>第四步，打开 <a href="http://localhost:9000/" target="_blank" rel="noopener">http://localhost:9000</a> 来查看前端，并进行管理。</p><p>添加远程查看</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -L 9000:127.0.0.1:9000 -p 10102 root@192.168.25.110</span><br></pre></td></tr></table></figure><h1 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h1><p>使用 yunjey 的一个 pytorch 教程作为演示，代码是演示用 pytorch 实现基于 CNN 的 MINIST 手写数字识别。</p><p>根据 Sacred 文档稍作修改，就可以演示如何进行实验的记录。</p><p>更多用法请去看 Sacred 文档：<a href="https://sacred.readthedocs.io/en/latest/" target="_blank" rel="noopener">Welcome to Sacred’s documentation!</a>。内容超丰富，功能超级多。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from sacred import Experiment</span><br><span class="line">from sacred.observers import MongoObserver</span><br><span class="line">from sacred.utils import apply_backspaces_and_linefeeds</span><br><span class="line"></span><br><span class="line">import torch</span><br><span class="line">import torch.nn as nn</span><br><span class="line">import torchvision</span><br><span class="line">import torchvision.transforms as transforms</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ex = Experiment(&quot;mnist_cnn&quot;)</span><br><span class="line">ex.observers.append(MongoObserver.create(url=&apos;localhost:27017&apos;,</span><br><span class="line">                                         db_name=&apos;sacred&apos;))</span><br><span class="line">ex.captured_out_filter = apply_backspaces_and_linefeeds</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 超参数设置</span><br><span class="line">@ex.config</span><br><span class="line">def myconfig():</span><br><span class="line">    # Device configuration</span><br><span class="line">    device = torch.device(&apos;cuda:0&apos; if torch.cuda.is_available() else &apos;cpu&apos;)</span><br><span class="line"></span><br><span class="line">    # Hyper parameters</span><br><span class="line">    num_epochs = 5</span><br><span class="line">    num_classes = 10</span><br><span class="line">    batch_size = 100</span><br><span class="line">    learning_rate = 0.001</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Convolutional neural network (two convolutional layers)</span><br><span class="line">class ConvNet(nn.Module):</span><br><span class="line">    def __init__(self, num_classes=10):</span><br><span class="line">        super(ConvNet, self).__init__()</span><br><span class="line">        self.layer1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(1, 16, kernel_size=5, stride=1, padding=2),</span><br><span class="line">            nn.BatchNorm2d(16),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(kernel_size=2, stride=2))</span><br><span class="line">        self.layer2 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(16, 32, kernel_size=5, stride=1, padding=2),</span><br><span class="line">            nn.BatchNorm2d(32),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(kernel_size=2, stride=2))</span><br><span class="line">        self.fc = nn.Linear(7 * 7 * 32, num_classes)</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        out = self.layer1(x)</span><br><span class="line">        out = self.layer2(out)</span><br><span class="line">        out = out.reshape(out.size(0), -1)</span><br><span class="line">        out = self.fc(out)</span><br><span class="line">        return out</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># notice how we can access the message here by taking it as an argument</span><br><span class="line">@ex.automain</span><br><span class="line">def main(device,num_epochs,num_classes,batch_size,learning_rate ):</span><br><span class="line">    # MNIST dataset</span><br><span class="line">    train_dataset = torchvision.datasets.MNIST(root=&apos;/home/ubuntu/Datasets/MINIST/&apos;,</span><br><span class="line">                                               train=True,</span><br><span class="line">                                               transform=transforms.ToTensor(),</span><br><span class="line">                                               download=True)</span><br><span class="line"></span><br><span class="line">    test_dataset = torchvision.datasets.MNIST(root=&apos;/home/ubuntu/Datasets/MINIST/&apos;,</span><br><span class="line">                                              train=False,</span><br><span class="line">                                              transform=transforms.ToTensor())</span><br><span class="line"></span><br><span class="line">    # Data loader</span><br><span class="line">    train_loader = torch.utils.data.DataLoader(dataset=train_dataset,</span><br><span class="line">                                               batch_size=batch_size,</span><br><span class="line">                                               shuffle=True)</span><br><span class="line"></span><br><span class="line">    test_loader = torch.utils.data.DataLoader(dataset=test_dataset,</span><br><span class="line">                                              batch_size=batch_size,</span><br><span class="line">                                              shuffle=False)</span><br><span class="line"></span><br><span class="line">    model = ConvNet(num_classes).to(device)</span><br><span class="line"></span><br><span class="line">    # Loss and optimizer</span><br><span class="line">    criterion = nn.CrossEntropyLoss()</span><br><span class="line">    optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)</span><br><span class="line"></span><br><span class="line">    # Train the model</span><br><span class="line">    total_step = len(train_loader)</span><br><span class="line">    for epoch in range(num_epochs):</span><br><span class="line">        for i, (images, labels) in enumerate(train_loader):</span><br><span class="line">            images = images.to(device)</span><br><span class="line">            labels = labels.to(device)</span><br><span class="line"></span><br><span class="line">            # Forward pass</span><br><span class="line">            outputs = model(images)</span><br><span class="line">            loss = criterion(outputs, labels)</span><br><span class="line"></span><br><span class="line">            # Backward and optimize</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            loss.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line"></span><br><span class="line">            if (i + 1) % 100 == 0:</span><br><span class="line">                print(&apos;Epoch [&#123;&#125;/&#123;&#125;], Step [&#123;&#125;/&#123;&#125;], Loss: &#123;:.4f&#125;&apos;</span><br><span class="line">                      .format(epoch + 1, num_epochs, i + 1, total_step, loss.item()))</span><br><span class="line"></span><br><span class="line">    # Test the model</span><br><span class="line">    model.eval()  # eval mode (batchnorm uses moving mean/variance instead of mini-batch mean/variance)</span><br><span class="line">    with torch.no_grad():</span><br><span class="line">        correct = 0</span><br><span class="line">        total = 0</span><br><span class="line">        for images, labels in test_loader:</span><br><span class="line">            images = images.to(device)</span><br><span class="line">            labels = labels.to(device)</span><br><span class="line">            outputs = model(images)</span><br><span class="line">            _, predicted = torch.max(outputs.data, 1)</span><br><span class="line">            total += labels.size(0)</span><br><span class="line">            correct += (predicted == labels).sum().item()</span><br><span class="line"></span><br><span class="line">        print(&apos;Test Accuracy of the model on the 10000 test images: &#123;&#125; %&apos;.format(100 * correct / total))</span><br><span class="line"></span><br><span class="line">    # Save the model checkpoint</span><br><span class="line">    torch.save(model.state_dict(), &apos;model.ckpt&apos;)</span><br></pre></td></tr></table></figure><p>执行完该程序后，可以打开 omniboard 前端 <a href="http://localhost:9000/" target="_blank" rel="noopener">http://localhost:9000</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Sacred-安装&quot;&gt;&lt;a href=&quot;#Sacred-安装&quot; class=&quot;headerlink&quot; title=&quot;Sacred 安装&quot;&gt;&lt;/a&gt;Sacred 安装&lt;/h3&gt;&lt;h4 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="深度学习环境配置" scheme="https://janvia.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="sacred" scheme="https://janvia.github.io/tags/sacred/"/>
    
  </entry>
  
  <entry>
    <title>wsl</title>
    <link href="https://janvia.github.io/2022/08/20/wsl/"/>
    <id>https://janvia.github.io/2022/08/20/wsl/</id>
    <published>2022-08-20T08:55:59.000Z</published>
    <updated>2024-10-18T01:37:21.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="wsl"><a href="#wsl" class="headerlink" title="wsl"></a>wsl</h3><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wsl -l -o #查看版本</span><br><span class="line">wsl --install -d Ubuntu-20.04</span><br><span class="line">wsl --install -d Ubuntu-18.04</span><br><span class="line">wsl --shutdown</span><br><span class="line">wsl --set-version Ubuntu-18.04 2</span><br><span class="line">wsl --set-version Ubuntu-20.04 1</span><br></pre></td></tr></table></figure><p>报错：Error code: Wsl/InstallDistro/WININET_E_NAME_NOT_RESOLVED<br>解决方法： 编辑<code>C:\Windows\System32\drivers\etc\hosts</code>添加内容<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">185.199.108.133 raw.githubusercontent.com</span><br><span class="line">185.199.109.133 raw.githubusercontent.com</span><br><span class="line">185.199.110.133 raw.githubusercontent.com</span><br><span class="line">185.199.111.133 raw.githubusercontent.com</span><br></pre></td></tr></table></figure></p><h5 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h5><p>1.设置防火墙 ,不勾选wsl</p><p>2.设置代理软件allow alan</p><p>3.安装配置proxychains4,见配置proxychains4</p><p>​    对于wsl2,配置的地址需要是ipconfig的地址172.xx.xx.1</p><h5 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h5><p>将wsl 安装在其他盘</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wsl --export Ubuntu-20.04 d:\wsl-ubuntu20.04.tar #导出</span><br><span class="line">wsl --unregister Ubuntu-20.04 #注销</span><br><span class="line">#重新导入</span><br><span class="line">wsl --import Ubuntu-20.04 d:\wsl-ubuntu20.04 d:\wsl-ubuntu20.04.tar --version 2</span><br><span class="line">ubuntu2004 config --default-user USERNAME #设置usr</span><br><span class="line">del d:\wsl-ubuntu20.04.tar#删除包</span><br></pre></td></tr></table></figure><h5 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h5><p>查看/etc/resolv.conf</p><p>如果出现网络错误,nameserver为红色</p><p>1.在/etc/wsl.conf中加入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[network]</span><br><span class="line">generateResolvConf = false</span><br></pre></td></tr></table></figure><p>2.PowerShell重启WSL</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wsl --shutdown</span><br></pre></td></tr></table></figure><p>3.修改/etc/resolv.conf,去掉发红的nameserver</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nameserver 223.5.5.5</span><br><span class="line">nameserver 223.6.6.6</span><br></pre></td></tr></table></figure><h4 id="网络故障修复"><a href="#网络故障修复" class="headerlink" title="网络故障修复"></a>网络故障修复</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wsl --shutdown</span><br><span class="line">netsh winsock reset</span><br><span class="line">netsh int ip reset all</span><br><span class="line">netsh winhttp reset proxy</span><br><span class="line">ipconfig /flushdns</span><br></pre></td></tr></table></figure><p>然后重启</p><h3 id="wsl-gui"><a href="#wsl-gui" class="headerlink" title="wsl gui"></a>wsl gui</h3><p>更新wsl,在powershell 或者windows cmd运行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wsl --update</span><br></pre></td></tr></table></figure><h4 id="google-chrome"><a href="#google-chrome" class="headerlink" title="google chrome"></a>google chrome</h4><p>安装</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /tmp</span><br><span class="line">wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb</span><br><span class="line">sudo apt install --fix-missing ./google-chrome-stable_current_amd64.deb</span><br></pre></td></tr></table></figure><p>启动：<code>google-chrome</code></p><h4 id="Microsoft-Edge"><a href="#Microsoft-Edge" class="headerlink" title="Microsoft Edge"></a>Microsoft Edge</h4><p>安装<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## Setup</span><br><span class="line">curl https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor &gt; microsoft.gpg</span><br><span class="line">sudo install -o root -g root -m 644 microsoft.gpg /usr/share/keyrings/</span><br><span class="line">sudo sh -c &apos;echo &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/microsoft.gpg] https://packages.microsoft.com/repos/edge stable main&quot; &gt; /etc/apt/sources.list.d/microsoft-edge-beta.list&apos;</span><br><span class="line">sudo rm microsoft.gpg</span><br><span class="line">## Install</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install microsoft-edge-beta</span><br></pre></td></tr></table></figure></p><p>启动： <code>microsoft-edge</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;wsl&quot;&gt;&lt;a href=&quot;#wsl&quot; class=&quot;headerlink&quot; title=&quot;wsl&quot;&gt;&lt;/a&gt;wsl&lt;/h3&gt;&lt;h5 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="linux" scheme="https://janvia.github.io/categories/linux/"/>
    
    
      <category term="wsl" scheme="https://janvia.github.io/tags/wsl/"/>
    
  </entry>
  
  <entry>
    <title>双系统安装</title>
    <link href="https://janvia.github.io/2022/08/20/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"/>
    <id>https://janvia.github.io/2022/08/20/双系统安装/</id>
    <published>2022-08-20T08:55:59.000Z</published>
    <updated>2024-11-16T05:41:54.730Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="需要的软件"><a href="#需要的软件" class="headerlink" title="需要的软件"></a>需要的软件</h3><p>启动盘和分区软件只需要任选其一</p><h4 id="启动盘制作软件"><a href="#启动盘制作软件" class="headerlink" title="启动盘制作软件"></a>启动盘制作软件</h4><p>1.rufus<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://github.com/pbatard/rufus/releases</span><br></pre></td></tr></table></figure></p><p>2.软碟通UltralSO<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://cn.ultraiso.net/uiso9_cn.exe</span><br></pre></td></tr></table></figure></p><p>3.大白菜启动盘制作<br>百度大白菜进入官网下载</p><h4 id="分区软件"><a href="#分区软件" class="headerlink" title="分区软件"></a>分区软件</h4><p>1.DiskGenius<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://www.diskgenius.cn/download.php</span><br></pre></td></tr></table></figure></p><p>2.系统自带(win11为例)<br>右键我的电脑选择属性<br>然后选择系统-&gt; 存储 -&gt; 磁盘和卷</p><h3 id="安装示例"><a href="#安装示例" class="headerlink" title="安装示例"></a>安装示例</h3><p>以软碟通和DiskGenius为例</p><h4 id="下载ubuntu"><a href="#下载ubuntu" class="headerlink" title="下载ubuntu"></a>下载ubuntu</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://cn.ubuntu.com/desktop</span><br></pre></td></tr></table></figure><h4 id="制作启动盘"><a href="#制作启动盘" class="headerlink" title="制作启动盘"></a>制作启动盘</h4><p>1.插入U盘，提前备份U盘内的数据，U盘大小要足够容纳ISO文件。<br>2.打开UltralSO，同时找到自己电脑中刚刚下好的ISO文件，直接拖拽文件到UltralSO工具中。<br>3.双击刚刚拖拽进来的iso文件，弹出选项卡，选择“是”，就打开ISO文件了。<br>4.单击工具栏上的“启动”-&gt;“写入硬盘映像”“，系统可能会询问管理员权限，选择“是”。然后选择硬盘驱动器为指定U盘，写入方式为USB-HDD+。<br>5.选择“写入”，一定要确保U盘里面的重要数据都备份了！！弹出警告也会提醒你，你确定的话就选择“是”。下面软件就会进行写入操作了，写入成功。</p><h4 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h4><p>1.打开DIskGenius，右键自己想要开辟分区的磁盘，选择“建立新分区”，然后输入自己想要开辟的分区大小，这里我开辟128G大小。<br>2.选择“开始”，这时候可以软件就开始工作了，我们等待它完成就好。<br>3.创建好分区后，将新建的分区删除，右键该盘块，选择“删除当前分区”，这样就会出现一个128G的空闲区域。<br>4.点击保存更改，退出软件。</p><h3 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h3><h4 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h4><p>1.重启电脑，按F9（暗影精灵） ，其他电脑可能是其他按钮F9-F12 ，选择U盘启动<br>2.选择try or install ubuntu<br>3.进入Ubuntu安装引导程序，选择中文，点击继续<br>4.选择chinese，点击继续<br>5.选择不连接网络，点击继续<br>6.选择最小安装，点击继续<br>7.选择其他（自定义安装）<br>8.选择创建出的空间的128G的那个分区，右键点击，选择新建分区，挂载点填写<code>/</code>,表示根目录，点击确定，点击继续<br>9.后面一路继续，填写用户信息，安装<br>10.安装完成后，重启，根据提示，拔掉U盘</p><h4 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h4><p>1.todesk无法连接，提示没有X11<br>点击左下角，选择软件和更新，选择附加驱动，选择安装nvidia最新驱动软件，安装完成重启<br>如果仍然不行，安装lightdm</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install lightdm</span><br></pre></td></tr></table></figure><p>2.安装nvidia驱动后，出现没有wifi<br>原因nvidia驱动的内核版本较新，只需要更新内核版本<br>更新方法：</p><ul><li>重启</li><li>选择第二项optional ubuntu</li><li>选择老版本内核版本的ubuntu进入，进入后有wifi</li><li>点击左下角，软件更新器，点击全部更新</li><li>重启</li></ul><h3 id="常用软件安装"><a href="#常用软件安装" class="headerlink" title="常用软件安装"></a>常用软件安装</h3><h4 id="miniconda"><a href="#miniconda" class="headerlink" title="miniconda"></a>miniconda</h4><p>官网</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://docs.conda.io/projects/miniconda/en/latest/</span><br></pre></td></tr></table></figure><p>安装<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/miniconda3</span><br><span class="line">wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh -O ~/miniconda3/miniconda.sh</span><br><span class="line">bash ~/miniconda3/miniconda.sh -b -u -p ~/miniconda3</span><br><span class="line">rm -rf ~/miniconda3/miniconda.sh</span><br></pre></td></tr></table></figure></p><p>环境配置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~/miniconda3/bin/conda init bash</span><br><span class="line">~/miniconda3/bin/conda init zsh</span><br></pre></td></tr></table></figure><h4 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h4><p>官网</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://code.visualstudio.com/</span><br></pre></td></tr></table></figure><p>安装常用插件</p><ul><li>python</li><li>c/c++</li><li>Cmake</li><li>Cmake Tools</li><li>Code Runner </li></ul><h4 id="pycharm"><a href="#pycharm" class="headerlink" title="pycharm"></a>pycharm</h4><p>官网</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://www.jetbrains.com/pycharm/</span><br></pre></td></tr></table></figure><h4 id="typora编辑器"><a href="#typora编辑器" class="headerlink" title="typora编辑器"></a>typora编辑器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#for Linux</span><br><span class="line"># or run:</span><br><span class="line"># sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE</span><br><span class="line">wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add -</span><br><span class="line"># add Typora&apos;s repository</span><br><span class="line">sudo add-apt-repository &apos;deb https://typora.io/linux ./&apos;</span><br><span class="line">sudo apt-get update</span><br><span class="line"># install typora</span><br><span class="line">sudo apt-get install typora</span><br></pre></td></tr></table></figure><h4 id="goodle浏览器"><a href="#goodle浏览器" class="headerlink" title="goodle浏览器"></a>goodle浏览器</h4><p>安装</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb</span><br><span class="line">sudo apt install ./google-chrome-stable_current_amd64.deb</span><br></pre></td></tr></table></figure><p>在安装 Google 浏览器的过程中，可能会遇到以下常见问题：</p><p>1, 依赖关系未满足</p><p>如果出现“依赖关系未满足”的错误，可以尝试在终端中输入以下命令以安装缺失的依赖包：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sudo apt install libgtk-3-engines libgtk-3-bin</span><br></pre></td></tr></table></figure><p>2, 安装失败</p><p>如果出现“安装失败”的错误，可以尝试重新下载安装包，或者使用以下命令卸载旧版本 Google 浏览器：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sudo dpkg -r google-chrome-stable</span><br></pre></td></tr></table></figure><h4 id="搜狗拼音"><a href="#搜狗拼音" class="headerlink" title="搜狗拼音"></a>搜狗拼音</h4><p>1，安装 fcitx</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install fcitx-bin</span><br><span class="line">sudo apt-get install fcitx-table</span><br></pre></td></tr></table></figure><p>2，下载搜狗官方安装包</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://pinyin.sogou.com/linux/</span><br></pre></td></tr></table></figure><p>3，安装依赖（这步很关键，否则安装完成后，无法输入中文）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install libqt5qml5 libqt5quick5 libqt5quickwidgets5 qml-module-qtquick2</span><br><span class="line">sudo apt install libgsettings-qt1</span><br></pre></td></tr></table></figure><p>4，安装刚才下载的搜狗输入法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~/Downloads/</span><br><span class="line">sudo dpkg -i sogoupinyin_4.0.1.2800_x86_64.deb</span><br></pre></td></tr></table></figure><p>5, 配置开机启动</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo cp /usr/share/applications/fcitx.desktop /etc/xdg/autostart/</span><br></pre></td></tr></table></figure><p>6, 卸载ibus</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt purge ibus</span><br></pre></td></tr></table></figure><p>7，切换 fcitx</p><ul><li>在系统设置中选择“区域与语言”，点击“管理已安装的语言</li><li>切换成“fcitx”，然后应用到整个系统</li><li>重启</li><li>点击右上角的小键盘图标，选择“配置当前输入法”</li><li>在配置界面，点击加号，选择“搜狗拼音输入法”即可<br>8, 关闭Wayland<br>在ubuntu22.04,必须关闭Wayland ，否则无法使用<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo gedit /etc/gdm3/custom.conf</span><br><span class="line">WaylandEnable=false</span><br></pre></td></tr></table></figure></li></ul><h4 id="clash"><a href="#clash" class="headerlink" title="clash"></a>clash</h4><p>1.安装<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir ~/.config/clash</span><br><span class="line">wget https://d2141svx4mhk4r.cloudfront.net/Clash.for.Linux-0.20.39-x64.tar.gz</span><br><span class="line">tar -zxvf Clash.for.Linux-0.20.39-x64.tar.gz</span><br><span class="line">cp Clash\ for\ Windows-0.20.39-x64-linux/resources/static/files/default/Country.mmdb ~/.config/clash/</span><br><span class="line">sudo cp Clash\ for\ Windows-0.20.39-x64-linux/resources/static/files/linux/x64/clash-linux /usr/bin/clash</span><br></pre></td></tr></table></figure></p><p>2.配置<br>复制订阅地址，在浏览器输入【 订阅地址加&amp;flag=clash 】 ，然后右击页面，选择“另存为”保存<br>然后将保存的文件修改为config.yaml<br>请将配置文件复制到 ~/.config/clash/config.yaml</p><p>3.配置代理<br>打开下面的网址访问管理页面<br><a href="http://clash.razord.top/#/proxies" target="_blank" rel="noopener">http://clash.razord.top/#/proxies</a></p><p>打开系统设置，选择网络，点击网络代理，选择手动<br>填写HTTP和HTTPS为127.0.0.1:7890，socks为127.0.0.1:7891</p><p>4.设置分流</p><p>点击左侧设置，代理模式使用 Rule模式。不推荐Global(全局)与Direct模式。<br>点击代理，可切换节点。</p><h3 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h3><p><a href="https://janvia.github.io/2019/01/07/%E6%8D%A2%E6%BA%90/">换源链接</a></p><h3 id="zsh配置"><a href="#zsh配置" class="headerlink" title="zsh配置"></a>zsh配置</h3><p><a href="https://janvia.github.io/2019/01/03/on-my-zsh/">oh-my-zsh</a></p><h3 id="截图软件安装"><a href="#截图软件安装" class="headerlink" title="截图软件安装"></a>截图软件安装</h3><p>推荐shuttle<br>1.添加 PPA：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository -y ppa:linuxuprising/shutter</span><br><span class="line">sudo apt update</span><br></pre></td></tr></table></figure></p><p>2.安装 Shutter：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install shutter</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;需要的软件&quot;&gt;&lt;a href=&quot;#需要的软件&quot; class=&quot;headerlink&quot; title=&quot;需要的软件&quot;&gt;&lt;/a&gt;需要的软件&lt;/h3&gt;&lt;p&gt;启动盘和分区软件只需要任选其一&lt;/p&gt;
&lt;h4 id=&quot;启动盘制作软件&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="linux" scheme="https://janvia.github.io/categories/linux/"/>
    
    
      <category term="双系统安装" scheme="https://janvia.github.io/tags/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg常用命令</title>
    <link href="https://janvia.github.io/2022/08/18/FFmpeg%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://janvia.github.io/2022/08/18/FFmpeg常用命令/</id>
    <published>2022-08-18T08:44:41.000Z</published>
    <updated>2022-08-19T15:18:57.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="FFmpeg常用命令"><a href="#FFmpeg常用命令" class="headerlink" title="FFmpeg常用命令"></a>FFmpeg常用命令</h3><h6 id="调整音量"><a href="#调整音量" class="headerlink" title="调整音量"></a>调整音量</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -i &#123;in_file&#125; -af &apos;volume=0.5&apos; &#123;out_file&#125;</span><br></pre></td></tr></table></figure><h6 id="截取音频"><a href="#截取音频" class="headerlink" title="截取音频"></a>截取音频</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -v 1 -y -i &#123;in_file&#125; -ss &#123;start&#125; -t 2 &#123;out_file&#125;</span><br></pre></td></tr></table></figure><p>-ss 开始时间，单位s</p><p>-t 截取时间，单位s</p><h6 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h6><p>wav 转 pcm</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -v 1 -y -i &#123;in_file&#125; -f s16le -ar 16000 -ac 1 -acodec pcm_s16le &#123;out_file&#125;</span><br></pre></td></tr></table></figure><p>pcm 转 wav</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -v 1 -y -f f32le -ar 48833 -i &#123;in_file&#125; -ar 16000 -ac 1 &#123;out_file&#125;</span><br></pre></td></tr></table></figure><p>int16:   s16le  float32: f32le</p><h6 id="resample"><a href="#resample" class="headerlink" title="resample"></a>resample</h6><p>pcm</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -v 1 -y -f s16le -i &#123;&#125; -f s16le -ar 16000 -ac 1 -acodec pcm_s16le &#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;FFmpeg常用命令&quot;&gt;&lt;a href=&quot;#FFmpeg常用命令&quot; class=&quot;headerlink&quot; title=&quot;FFmpeg常用命令&quot;&gt;&lt;/a&gt;FFmpeg常用命令&lt;/h3&gt;&lt;h6 id=&quot;调整音量&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="工具" scheme="https://janvia.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="ffmpeg" scheme="https://janvia.github.io/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>linux系统代理</title>
    <link href="https://janvia.github.io/2022/08/18/linux%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86/"/>
    <id>https://janvia.github.io/2022/08/18/linux系统代理/</id>
    <published>2022-08-18T08:44:41.000Z</published>
    <updated>2024-03-23T08:20:27.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="linux系统代理"><a href="#linux系统代理" class="headerlink" title="linux系统代理"></a>linux系统代理</h3><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install proxychains4</span><br></pre></td></tr></table></figure><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/proxychains4.conf</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ProxyList]</span><br><span class="line"># add proxy here ...</span><br><span class="line"># meanwile</span><br><span class="line"># defaults set to &quot;tor&quot;</span><br><span class="line">#socks4    127.0.0.1 9050</span><br><span class="line"></span><br><span class="line"># example</span><br><span class="line">socks5  127.0.0.1 8888</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;linux系统代理&quot;&gt;&lt;a href=&quot;#linux系统代理&quot; class=&quot;headerlink&quot; title=&quot;linux系统代理&quot;&gt;&lt;/a&gt;linux系统代理&lt;/h3&gt;&lt;h5 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; c
      
    
    </summary>
    
      <category term="工具" scheme="https://janvia.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="代理" scheme="https://janvia.github.io/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>matplotlib补充</title>
    <link href="https://janvia.github.io/2022/08/18/matplotlib%E8%A1%A5%E5%85%85/"/>
    <id>https://janvia.github.io/2022/08/18/matplotlib补充/</id>
    <published>2022-08-18T08:44:41.000Z</published>
    <updated>2022-08-19T15:21:29.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="防止中文乱码"><a href="#防止中文乱码" class="headerlink" title="防止中文乱码"></a>防止中文乱码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import matplotlib as mpl</span><br><span class="line">mpl.rcParams[&apos;font.sans-serif&apos;] = [u&apos;simHei&apos;]</span><br><span class="line">mpl.rcParams[&apos;axes.unicode_minus&apos;] = False</span><br></pre></td></tr></table></figure><h4 id="调整子图布局"><a href="#调整子图布局" class="headerlink" title="调整子图布局"></a>调整子图布局</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plt.tight_layout()</span><br></pre></td></tr></table></figure><h4 id="设置坐标轴"><a href="#设置坐标轴" class="headerlink" title="设置坐标轴"></a>设置坐标轴</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">axis(‘off’)#：关闭轴线和标签。</span><br><span class="line">axis(‘equal’)#：使x轴与y轴保持与屏幕一致的高宽比（横纵比）。</span><br><span class="line">axis(‘tight’)#：使x轴与y轴限制在有数据的区域。</span><br><span class="line">axis(‘square’)#：使x轴与y轴坐标一致。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;防止中文乱码&quot;&gt;&lt;a href=&quot;#防止中文乱码&quot; class=&quot;headerlink&quot; title=&quot;防止中文乱码&quot;&gt;&lt;/a&gt;防止中文乱码&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;
      
    
    </summary>
    
      <category term="工具" scheme="https://janvia.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="matplotlib" scheme="https://janvia.github.io/tags/matplotlib/"/>
    
  </entry>
  
  <entry>
    <title>linux常用命令</title>
    <link href="https://janvia.github.io/2022/08/18/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://janvia.github.io/2022/08/18/常用命令/</id>
    <published>2022-08-18T08:44:41.000Z</published>
    <updated>2024-11-16T14:43:44.980Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>所有权限</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod -R 777 test_out</span><br></pre></td></tr></table></figure><p>可以用来查看分区的文件系统</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df -T</span><br></pre></td></tr></table></figure><p>显示目前所有文件系统的可用空间及使用情形</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">du -h --max-depth=1 /home</span><br></pre></td></tr></table></figure><p>命令行代理</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxychains4 curl www.google.com</span><br></pre></td></tr></table></figure><p>服务器拷贝</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rsync -avzP -e &apos;ssh -p 10101&apos; dcase2020_task2/</span><br><span class="line">root@192.168.25.110:/data/dcase/dcase2020_task2</span><br></pre></td></tr></table></figure><p>打开scared</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">omniboard -m 192.168.2.111:27017:sacred</span><br></pre></td></tr></table></figure><p>自动安装依赖</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install aptitude</span><br><span class="line">sudo aptitude install xxx</span><br></pre></td></tr></table></figure><p>多线程下载<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aria2c --split=16 --max-connection-per-server=16 --min-split-size=1M --dir=./downloads https://example.com/file.zip</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;常用命令&quot;&gt;&lt;a href=&quot;#常用命令&quot; class=&quot;headerlink&quot; title=&quot;常用命令&quot;&gt;&lt;/a&gt;常用命令&lt;/h3&gt;&lt;p&gt;所有权限&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;ta
      
    
    </summary>
    
      <category term="工具" scheme="https://janvia.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="linux命令" scheme="https://janvia.github.io/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>R配置jupyter</title>
    <link href="https://janvia.github.io/2022/08/07/R%E9%85%8D%E7%BD%AEjupyter/"/>
    <id>https://janvia.github.io/2022/08/07/R配置jupyter/</id>
    <published>2022-08-07T08:44:41.000Z</published>
    <updated>2022-08-09T12:50:06.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h3><p>官网：<a href="https://www.anaconda.com/" target="_blank" rel="noopener">https://www.anaconda.com/</a><br>最新版本下载地址：<a href="https://www.anaconda.com/download/" target="_blank" rel="noopener">https://www.anaconda.com/download/</a><br>历史版本：<a href="https://repo.anaconda.com/archive/" target="_blank" rel="noopener">https://repo.anaconda.com/archive/</a></p><h3 id="Anaconda的安装"><a href="#Anaconda的安装" class="headerlink" title="Anaconda的安装"></a>Anaconda的安装</h3><p>进入文件所在路径<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash Anaconda3-4.4.0-Linux-x86_64.sh (下载的对应的文件名)</span><br></pre></td></tr></table></figure></p><h3 id="conda的环境管理"><a href="#conda的环境管理" class="headerlink" title="conda的环境管理"></a>conda的环境管理</h3><p>比如创建名为R4的R环境<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda create --name R4 r-base -c conda-forge</span><br></pre></td></tr></table></figure></p><p>激活R环境<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda activate R4</span><br></pre></td></tr></table></figure></p><p>测试环境<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">R</span><br></pre></td></tr></table></figure></p><p>退出R环境<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">q()</span><br></pre></td></tr></table></figure></p><p>删除虚拟环境<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda remove --name R4 --all</span><br></pre></td></tr></table></figure></p><h3 id="jupter-notebook添加R环境"><a href="#jupter-notebook添加R环境" class="headerlink" title="jupter notebook添加R环境"></a>jupter notebook添加R环境</h3><p>首先安装：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda install jupyter</span><br></pre></td></tr></table></figure></p><p>进入R环境<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">R</span><br></pre></td></tr></table></figure></p><p>安装和配置kernal<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">install.packages(&apos;IRkernel&apos;)</span><br><span class="line"></span><br><span class="line">IRkernel::installspec()</span><br></pre></td></tr></table></figure></p><h3 id="启动jupter-notebook"><a href="#启动jupter-notebook" class="headerlink" title="启动jupter notebook"></a>启动jupter notebook</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure><h3 id="R更换下载源"><a href="#R更换下载源" class="headerlink" title="R更换下载源"></a>R更换下载源</h3><p>查看和配置<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">options(&quot;repos&quot;)</span><br><span class="line">options(repos=&quot;https://mirrors.tuna.tsinghua.edu.cn/CRAN/&quot;),</span><br><span class="line">options(&quot;repos&quot;)</span><br></pre></td></tr></table></figure></p><h3 id="R2jags的安装（windows）"><a href="#R2jags的安装（windows）" class="headerlink" title="R2jags的安装（windows）"></a>R2jags的安装（windows）</h3><p>首先在 <a href="http://mcmc-jags.sourceforge.net/" target="_blank" rel="noopener">http://mcmc-jags.sourceforge.net/</a> 下载JAGS ， 注意版本问题，由于rjags依赖JAGS，rjags未必支持最新版，可下载早期稳定版本。这里下载4.3.0版本，然后安装</p><p>手动配置库目录<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sys.setenv(JAGS_HOME=&quot;C:/Program Files/JAGS/JAGS-4.3.0&quot;)</span><br></pre></td></tr></table></figure></p><p>安装<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">install.packages(&apos;R2jags&apos;)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;下载地址&quot;&gt;&lt;a href=&quot;#下载地址&quot; class=&quot;headerlink&quot; title=&quot;下载地址&quot;&gt;&lt;/a&gt;下载地址&lt;/h3&gt;&lt;p&gt;官网：&lt;a href=&quot;https://www.anaconda.com/&quot; targe
      
    
    </summary>
    
      <category term="工具" scheme="https://janvia.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="R" scheme="https://janvia.github.io/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>JNA</title>
    <link href="https://janvia.github.io/2019/06/07/JNA/"/>
    <id>https://janvia.github.io/2019/06/07/JNA/</id>
    <published>2019-06-07T04:53:47.000Z</published>
    <updated>2024-04-26T13:27:40.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="step1-生成动态库"><a href="#step1-生成动态库" class="headerlink" title="step1:生成动态库"></a>step1:生成动态库</h3><p>1、编写头文件 #hellworld.h</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test();</span><br></pre></td></tr></table></figure><p>2、编写实现文件 #helloworld.c</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;  </span><br><span class="line">void test()&#123;  </span><br><span class="line">printf(&quot;helloworld\n&quot;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、编译生成动态库，文件名:libhello.so</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -fpic -shared -o libhello.so helloworld.c</span><br></pre></td></tr></table></figure><p> 文件libhello.so生成。</p><h3 id="step2-添加maven配置"><a href="#step2-添加maven配置" class="headerlink" title="step2:添加maven配置"></a>step2:添加maven配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;  </span><br><span class="line">     &lt;groupId&gt;com.sun.jna&lt;/groupId&gt;  </span><br><span class="line">     &lt;artifactId&gt;jna&lt;/artifactId&gt;  </span><br><span class="line">     &lt;version&gt;3.0.9&lt;/version&gt;  </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="step3-编写测试类"><a href="#step3-编写测试类" class="headerlink" title="step3:编写测试类"></a>step3:编写测试类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import com.sun.jna.Library;  </span><br><span class="line">import com.sun.jna.Native;  </span><br><span class="line">  </span><br><span class="line">public class JnaTest &#123;  </span><br><span class="line">  </span><br><span class="line">//继承Library，用于加载库文件  </span><br><span class="line">public interface Clibrary extends Library&#123;  </span><br><span class="line">//加载libhello.so链接库  </span><br><span class="line">Clibrary INSTANTCE = (Clibrary) Native.loadLibrary(&quot;hello&quot;, Clibrary.class);  </span><br><span class="line">  </span><br><span class="line">//此方法为链接库中的方法  </span><br><span class="line">void test();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">public static void main(String[] args) &#123;  </span><br><span class="line">//调用  </span><br><span class="line">Clibrary.INSTANTCE.test();  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="step4-解决路径问题"><a href="#step4-解决路径问题" class="headerlink" title="step4:解决路径问题"></a>step4:解决路径问题</h3><p>比如复制libtest.so到公共库</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;step1-生成动态库&quot;&gt;&lt;a href=&quot;#step1-生成动态库&quot; class=&quot;headerlink&quot; title=&quot;step1:生成动态库&quot;&gt;&lt;/a&gt;step1:生成动态库&lt;/h3&gt;&lt;p&gt;1、编写头文件 #hellworld.h&lt;/p&gt;
&lt;figure c
      
    
    </summary>
    
      <category term="深度学习移植" scheme="https://janvia.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%A7%BB%E6%A4%8D/"/>
    
    
      <category term="java调用C" scheme="https://janvia.github.io/tags/java%E8%B0%83%E7%94%A8C/"/>
    
  </entry>
  
  <entry>
    <title>jni</title>
    <link href="https://janvia.github.io/2019/06/03/jni/"/>
    <id>https://janvia.github.io/2019/06/03/jni/</id>
    <published>2019-06-03T13:27:30.000Z</published>
    <updated>2024-04-26T13:27:57.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="STEP1-编写java调用文件"><a href="#STEP1-编写java调用文件" class="headerlink" title="STEP1  编写java调用文件"></a>STEP1  编写java调用文件</h3><p>J2C.java</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.lang.management.ManagementFactory;</span><br><span class="line">import java.lang.management.RuntimeMXBean;</span><br><span class="line"></span><br><span class="line">public class J2C</span><br><span class="line">&#123; </span><br><span class="line">     static </span><br><span class="line">     &#123; </span><br><span class="line">          try&#123; </span><br><span class="line">               // 此处即为本地方法所在链接库名</span><br><span class="line">               System.loadLibrary(&quot;j2c&quot;);</span><br><span class="line">          &#125; catch(UnsatisfiedLinkError e) </span><br><span class="line">          &#123; </span><br><span class="line">               System.err.println( &quot;Cannot load J2C library:\n &quot; + </span><br><span class="line">               e.toString() ); </span><br><span class="line">          &#125; </span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     //声明的本地方法</span><br><span class="line">     public static native int write2proc(int pid);</span><br><span class="line"></span><br><span class="line">     public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">          //获取本进程(即主线程)的pid</span><br><span class="line">          final RuntimeMXBean runtime = ManagementFactory.getRuntimeMXBean();</span><br><span class="line">          final String info = runtime.getName();</span><br><span class="line">          final int index = info.indexOf(&quot;@&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          if (index != -1) &#123;</span><br><span class="line">               final int pid = Integer.parseInt(info.substring(0, index));</span><br><span class="line">               System.out.println(info);</span><br><span class="line">               System.out.println(pid);</span><br><span class="line"></span><br><span class="line">               write2proc(pid);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          try&#123;</span><br><span class="line">               Thread.sleep(8000);</span><br><span class="line">          &#125; catch(InterruptedException e)&#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step2-生成J2C-h"><a href="#Step2-生成J2C-h" class="headerlink" title="Step2 生成J2C.h"></a>Step2 生成J2C.h</h3><p>bash: javac -h ./ J2C.java</p><p>以下内容为自动生成：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* DO NOT EDIT THIS FILE - it is machine generated */</span><br><span class="line">#include &lt;jni.h&gt;</span><br><span class="line">/* Header for class J2C */</span><br><span class="line"></span><br><span class="line">#ifndef _Included_J2C</span><br><span class="line">#define _Included_J2C</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line">/*</span><br><span class="line"> * Class:     J2C</span><br><span class="line"> * Method:    write2proc</span><br><span class="line"> * Signature: (I)I</span><br><span class="line"> */</span><br><span class="line">JNIEXPORT jint JNICALL Java_J2C_write2proc</span><br><span class="line">  (JNIEnv *, jclass, jint);</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h3 id="Step3-编写J2C-c"><a href="#Step3-编写J2C-c" class="headerlink" title="Step3 编写J2C.c"></a>Step3 编写J2C.c</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;J2C.h&quot;</span><br><span class="line"></span><br><span class="line">JNIEXPORT int JNICALL Java_J2C_write2proc(JNIEnv * env, jobject arg, jint pid) </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">     printf(&quot;current pid is %d\n&quot;, pid);</span><br><span class="line"></span><br><span class="line">     return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step4-生成J2C-so"><a href="#Step4-生成J2C-so" class="headerlink" title="Step4 生成J2C.so"></a>Step4 生成J2C.so</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash: gcc J2C.c -fPIC -shared -o libJ2C.so</span><br></pre></td></tr></table></figure><p>利用gcc、g++编译源文件找不到jni.h头文件:</p><p>可以在编译时利用-I选项指定jni.h头文件所在目录：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc J2C.c -fPIC -shared -o libJ2C.so -I /usr/java/jdk-12.0.1/include/ -I /usr/java/jdk-12.0.1/include/linux/</span><br></pre></td></tr></table></figure><p>注意：cmake make 找不到jni.h的情况，可以将文件复制到公共库/usr/include/</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;STEP1-编写java调用文件&quot;&gt;&lt;a href=&quot;#STEP1-编写java调用文件&quot; class=&quot;headerlink&quot; title=&quot;STEP1  编写java调用文件&quot;&gt;&lt;/a&gt;STEP1  编写java调用文件&lt;/h3&gt;&lt;p&gt;J2C.java&lt;/p&gt;
      
    
    </summary>
    
      <category term="深度学习移植" scheme="https://janvia.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%A7%BB%E6%A4%8D/"/>
    
    
      <category term="java调用C" scheme="https://janvia.github.io/tags/java%E8%B0%83%E7%94%A8C/"/>
    
  </entry>
  
  <entry>
    <title>30单元</title>
    <link href="https://janvia.github.io/2019/05/12/30%E5%8D%95%E5%85%83/"/>
    <id>https://janvia.github.io/2019/05/12/30单元/</id>
    <published>2019-05-12T14:36:35.000Z</published>
    <updated>2019-05-12T15:08:11.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="お／ごVです＜尊他＞"><a href="#お／ごVです＜尊他＞" class="headerlink" title="お／ごＶです＜尊他＞"></a>お／ごＶです＜尊他＞</h3><p>动词敬语表现形式之一，用来表示对动作主体的敬意。<br>接续：Ｖます形/サ変V词干<br> 中文翻译成：“您~~”</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">１.シンポジウムには遠藤先生もご出席でした。</span><br><span class="line">２.お客様、何かお探しですか。</span><br><span class="line">３.遠藤先生！今、お帰りですか。</span><br><span class="line">４.佐藤部長はあしたから、ご旅行で3週間いらっしゃらないそうです。</span><br></pre></td></tr></table></figure><h3 id="V（ら）れる＜尊他＞"><a href="#V（ら）れる＜尊他＞" class="headerlink" title="V（ら）れる＜尊他＞"></a>V（ら）れる＜尊他＞</h3><p>表示对动作主体的敬意。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">１.佐藤さんは何時に帰られましたか。(2003年真题)</span><br><span class="line">２.この本は、遠藤先生が書かれた本です。</span><br><span class="line">３.昨日、胡先生が来られて、教えてくださいました。</span><br></pre></td></tr></table></figure><p>一类动词：将词尾う段假名变成相应行的あ段假名，再加 れる。<br>               書く　書かれる        読む　読まれる</p><p>二类动词：将词尾的る去掉，再加られる。<br>               　　　見る　見られる       ほめる　　褒められる</p><p>三类动词：　　来る　来られる（こられる）<br>                         する　　　　　　される　<br>　　　　          勉強する　　　　　勉強される</p><h3 id="Vていただけませんか＜请求＞"><a href="#Vていただけませんか＜请求＞" class="headerlink" title="Vていただけませんか＜请求＞"></a>Vていただけませんか＜请求＞</h3><p>表示请求时要使用授受动词来表示说话人受益，一种礼貌的方式。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">１.明日、こちらに来ていただけませんか。</span><br><span class="line">２.これを翻訳していただけませんか。</span><br><span class="line">３.お昼頃、来ていただけませんか。</span><br><span class="line">４.後5分、待っていただけませんか。</span><br></pre></td></tr></table></figure><p>如果想表示更加谦恭的请求，还可以使用：<br>“お/ご～いただけませんか”<br>もうすこし　お待ち　いただけないでしょうか。</p><h3 id="Nのところ-lt-处所化-gt"><a href="#Nのところ-lt-处所化-gt" class="headerlink" title="Nのところ&lt;处所化&gt;"></a>Nのところ&lt;处所化&gt;</h3><p>一、表示人或物的名词后加上“のところ”才可与移动动词或存在动词等搭配使用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.前にお借りした本を先生のところに返しにいきました。</span><br><span class="line">2.図書館に入ったら、高橋さんはまずパソコンのところに行って検索してみた。</span><br></pre></td></tr></table></figure><p>二、接在 “今、現在、この”等表示“现在”的名词后，表示“现阶段、现在时点”等现在的时间性状况。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">１.今のところ応募者は約100人ほどです。</span><br><span class="line">２.このところ雨の日が続いている。</span><br><span class="line">３.お忙しいところ、申し訳ありません。</span><br></pre></td></tr></table></figure><h3 id="V-よ-うとする-lt-意图-gt"><a href="#V-よ-うとする-lt-意图-gt" class="headerlink" title="V(よ)うとする&lt;意图&gt;"></a>V(よ)うとする&lt;意图&gt;</h3><p>接意志性动词后，表示为达到某目的而努力尝试进行该动作。<br>接续：Ｖようとする<br>汉语：想要~</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.彼女は25歳になる前に何とか結婚しようとしている。</span><br><span class="line">2.いくら思い出そうとしても、名前が思い出せない。</span><br><span class="line">3.寝ようとすればするほど、目がさえてきてしまった。</span><br></pre></td></tr></table></figure><p>通常以「ｖ（よ）うとしたとき」「ｖ（よ）うとしたところ」的形式，表示正要实施该动作。“正要~（的候）”</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4.電車を降りようとしたとき、財布を忘れたことに気がついた。</span><br></pre></td></tr></table></figure><h3 id="うちに-lt-发生变化的时间范围-gt"><a href="#うちに-lt-发生变化的时间范围-gt" class="headerlink" title="~うちに &lt;发生变化的时间范围&gt;"></a>~うちに &lt;发生变化的时间范围&gt;</h3><p>表示在某一状态持续时或某一动作（反复）进行过程中，发生了某一变化。<br>接续： V-る / V-ている + うちに</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.彼女は話しているうちに顔が真っ赤になった。</span><br><span class="line">2.昨夜、部屋で小説を読んでいるうちに、寝てしまいました。</span><br><span class="line">3.日本人と話すうちに、日本語の発音がよくなった。</span><br></pre></td></tr></table></figure><h3 id="うちに＜时段＞"><a href="#うちに＜时段＞" class="headerlink" title="~うちに＜时段＞"></a>~うちに＜时段＞</h3><p>前接表示状态的词，表示在该状态持续期间内，发生了某件事或做某件事（有尽快进行该动作的语感）。</p><p>接续：<br>N + の　　　　　　　　　 + うちに<br>N + な　　　　　　　　　 + うちに<br>A-い  　　　　　　　　　  + うちに<br>V-る / V-ている  V-ない　 + うちに<br>汉语 ：趁着~、~时候、在~之内</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.どうぞ、温かいうちに食べてください。（2008年真题）</span><br><span class="line">2.父が元気なうちに、一度一緒に温泉に行きたいと思います。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;お／ごVです＜尊他＞&quot;&gt;&lt;a href=&quot;#お／ごVです＜尊他＞&quot; class=&quot;headerlink&quot; title=&quot;お／ごＶです＜尊他＞&quot;&gt;&lt;/a&gt;お／ごＶです＜尊他＞&lt;/h3&gt;&lt;p&gt;动词敬语表现形式之一，用来表示对动作主体的敬意。&lt;br&gt;接续：Ｖます形/サ変
      
    
    </summary>
    
      <category term="日语" scheme="https://janvia.github.io/categories/%E6%97%A5%E8%AF%AD/"/>
    
    
      <category term="语法" scheme="https://janvia.github.io/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>29单元</title>
    <link href="https://janvia.github.io/2019/05/02/29%E5%8D%95%E5%85%83/"/>
    <id>https://janvia.github.io/2019/05/02/29单元/</id>
    <published>2019-05-02T02:11:54.000Z</published>
    <updated>2019-05-02T02:25:06.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="～てしかたがない＜极端的心理状态＞"><a href="#～てしかたがない＜极端的心理状态＞" class="headerlink" title="～てしかたがない＜极端的心理状态＞"></a>～てしかたがない＜极端的心理状态＞</h3><p>　多接在表示感情、感觉或者生理现象的词后，表示产生某种感情或感觉自然产生，难以控制。主语一般为第一人称。第三人称时需在句末加「らしい」「そうだ」「ようだ」<br>接续：Aくて・NAで・Ｖて<br>汉语：…得不得了，…得很<br>★也可为：～てしょうがない　～てしようがない</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 先生に褒められて、嬉しくてしかたがない。</span><br><span class="line">2. 夕べ徹夜したので、眠くてしょうがない。(2008年真题)</span><br><span class="line">3. この映画は見るたびに、涙が出てしかたがない。</span><br></pre></td></tr></table></figure><h3 id="Nさえ～ば、～-lt-充分条件-gt"><a href="#Nさえ～ば、～-lt-充分条件-gt" class="headerlink" title="Nさえ～ば、～&lt;充分条件&gt;　"></a>Nさえ～ば、～&lt;充分条件&gt;　</h3><p>强调只要具备该条件，后项就会得出某结论或进行某动作。 「が」「を」格名词后接「さえ」时，其常常省略。<br>汉语：只要…就…</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.日本語さえ使えれば、バイト代は安くてもいいんです。</span><br><span class="line">2.自分さえよければいい。(2004年真题)</span><br><span class="line">3.新しいパソコンさえあれば、あとは何も欲しくない。</span><br><span class="line">4.値段さえ安ければ買うつもりです。</span><br><span class="line">5.手続きさえ簡単なら(ば)もっと多くの人が利用できるだろう。</span><br></pre></td></tr></table></figure><h3 id="（Nに）Vてほしい-Vないでほしい"><a href="#（Nに）Vてほしい-Vないでほしい" class="headerlink" title="（Ｎに）Ｖてほしい/Vないでほしい"></a>（Ｎに）Ｖてほしい/Vないでほしい</h3><p>表说话人希望对方或他人为自己做某事。动作的主体用「に」提示。<br>汉语：希望……/希望不要……<br>★：＝ＮにＶてもらいたい</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.あしたの演奏会には、ぜひ多くの人に来て欲しいです。</span><br><span class="line">2.今忙しいから邪魔しないで欲しい。</span><br><span class="line">3.この歌が少し難しいから、ほかのにしてほしい。(2011年真题)</span><br></pre></td></tr></table></figure><p>谓语动词也可用非自主动词表希望某事发生或不发生。<br>动作的主体用「が」提示。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.早く夏休みが始まって欲しい。</span><br><span class="line">2.あしたは友達と遠足に行くので、雨が降らないで欲しい。</span><br></pre></td></tr></table></figure><h3 id="に（表示主体）"><a href="#に（表示主体）" class="headerlink" title="に（表示主体）"></a>に（表示主体）</h3><p>接表人的名词后，谓语为表能力的动词，表示能力的主体。<br>谓语部分为否定时，常用「には」提示主体。<br>★「疑问词+にも～～ない」表示全面的否定“谁也不能”</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.私にできるかな…。</span><br><span class="line">2.みんなにわかるように、ゆっくり話してください。</span><br><span class="line">3.こんな難しい文章は、学生には翻訳できない。</span><br><span class="line">4.こんな難しいテスト、誰にもできないだろう。</span><br></pre></td></tr></table></figure><h3 id="N・Aでいらっしゃる＜尊他＞"><a href="#N・Aでいらっしゃる＜尊他＞" class="headerlink" title="Ｎ・Aでいらっしゃる＜尊他＞"></a>Ｎ・Aでいらっしゃる＜尊他＞</h3><p>「～です」的尊他表现形式，用于他人，表示尊敬。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.こちらは鈴木さんのお母様でいらっしゃいます。</span><br><span class="line">2.失礼ですが、どちらさまでいらっしゃいますか。</span><br><span class="line">3.お元気でいらっしゃいますか。</span><br><span class="line">4.いつもお若くていらっしゃいます。</span><br></pre></td></tr></table></figure><h3 id="Vていらっしゃる-lt-尊他-gt"><a href="#Vていらっしゃる-lt-尊他-gt" class="headerlink" title="Ｖていらっしゃる&lt;尊他&gt;"></a>Ｖていらっしゃる&lt;尊他&gt;</h3><p>「ている」的尊他表现形式，表示对动作主体的敬意。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.先生は今、新聞を読んでいらっしゃいます。</span><br><span class="line">2.お仕事は何をしていらっしゃいますか。</span><br></pre></td></tr></table></figure><h3 id="～とは限らない-lt-否定性可能-gt"><a href="#～とは限らない-lt-否定性可能-gt" class="headerlink" title="～とは限らない&lt;否定性可能&gt;"></a>～とは限らない&lt;否定性可能&gt;</h3><p>接在简体句后（N和AⅡ也可直接接）<br>表示事实未必如此、不能如此断定之意，暗示存在例外的情况。<br>常与副词「必ずしも」搭配<br>汉语：不一定…，未必…，并非…</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.高い料理が必ずしも美味しいとは限らない。</span><br><span class="line">2.実力のあるチームがいつも勝つとは限らない。 (2009年真题)</span><br></pre></td></tr></table></figure><h3 id="N-らしい-lt-风格、特征-gt"><a href="#N-らしい-lt-风格、特征-gt" class="headerlink" title="N+らしい&lt;风格、特征&gt;"></a>N+らしい&lt;风格、特征&gt;</h3><p>接在N后，按照A活用，表示具有该名词所示事物的特点、风格之意。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.鈴木さんは学生らしい格好で大学に来た。</span><br><span class="line">2.そんなことでくよくよするなんて、君らしくない。</span><br><span class="line">3.学生らしくもっと勉強しなさい。(2005年真题)</span><br><span class="line">4.自分らしさを見出してください。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;～てしかたがない＜极端的心理状态＞&quot;&gt;&lt;a href=&quot;#～てしかたがない＜极端的心理状态＞&quot; class=&quot;headerlink&quot; title=&quot;～てしかたがない＜极端的心理状态＞&quot;&gt;&lt;/a&gt;～てしかたがない＜极端的心理状态＞&lt;/h3&gt;&lt;p&gt;　多接在表示感情、感
      
    
    </summary>
    
      <category term="日语" scheme="https://janvia.github.io/categories/%E6%97%A5%E8%AF%AD/"/>
    
    
      <category term="语法" scheme="https://janvia.github.io/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>28单元</title>
    <link href="https://janvia.github.io/2019/05/01/28%E5%8D%95%E5%85%83/"/>
    <id>https://janvia.github.io/2019/05/01/28单元/</id>
    <published>2019-05-01T15:38:40.000Z</published>
    <updated>2019-05-01T16:14:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ず-に-lt-否定性状态-gt"><a href="#ず-に-lt-否定性状态-gt" class="headerlink" title="ず(に)&lt;否定性状态&gt;"></a>ず(に)&lt;否定性状态&gt;</h3><p>「Vず(に)」是「Vないで」的书面语形式.接续方式与ない基本相同。注意「する」变为「せず」。表示动作，状态的否定，用于中顿或并列。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">１.彼は今は1日も休まずに、まじめに働いてる。</span><br><span class="line">２.昨日は忙しくて、夜10時まで何も食べずに働いた。(2009年真题)</span><br><span class="line">３.辞書を使わずに日本語の新聞を読むことができるか。(2007年真题)</span><br></pre></td></tr></table></figure><h3 id="～Vるには＜目的＞"><a href="#～Vるには＜目的＞" class="headerlink" title="～Vるには＜目的＞"></a>～Vるには＜目的＞</h3><p>①当主句谓语动词为非自主动词时，表示要达到该目的所必须的条件，<br>②当主句谓语动词为自主动词时，表示为达到该目的所采用的手段、方法或是必须付出的努力。（结尾多使用~なければならない；～べきだ）　　<br>与「Vるために」同义、也可以使用「Ｖるためには」形式。<br>接续：动词原形</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 会議で使う資料に間違いがあったが、今から作り直すには時間が足りない。(2013年7月真题)</span><br><span class="line">2. 日本語が上手になるには一生懸命勉強しなければなりません。　</span><br><span class="line">3. 東京駅に行くには、そこの角を右に曲がったほうがいいよ。(2002年真题)</span><br></pre></td></tr></table></figure><h3 id="Vる-ようになる-lt-变化-gt"><a href="#Vる-ようになる-lt-变化-gt" class="headerlink" title="Vる　ようになる&lt;变化&gt;"></a>Vる　ようになる&lt;变化&gt;</h3><p>表示事物的变化。<br>汉语：变得可以了···；逐渐会····</p><h4 id="a-能力的从无到有"><a href="#a-能力的从无到有" class="headerlink" title="a.  能力的从无到有"></a>a.  能力的从无到有</h4><p>​      表示获得了该能力，即由原来不具备该能力、变得开始具备该能力。否定形式「Vるようにならない」表示尚未获得该能力。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">１.私は日本語が話せるようになった。</span><br><span class="line">２.日本へ来てから、日本料理が作れるようになった。</span><br></pre></td></tr></table></figure><h4 id="b-现象的出现（从无到有）"><a href="#b-现象的出现（从无到有）" class="headerlink" title="b.  现象的出现（从无到有）"></a>b.  现象的出现（从无到有）</h4><p>否定形式「Vるようにならない」表示该现象尚未出现。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">１.小学校は入学したころから、だんだん風邪を引いたり熱を出したりしないようになった。(2011年真题)</span><br><span class="line">２.日本では、なかなか女性と男性が同じ条件で働けるようにならない。</span><br></pre></td></tr></table></figure><h4 id="c-动作行为的习惯化（习惯的从无到有）"><a href="#c-动作行为的习惯化（习惯的从无到有）" class="headerlink" title="c.动作行为的习惯化（习惯的从无到有）"></a>c.动作行为的习惯化（习惯的从无到有）</h4><p> 否定形式「Vるようにならない」表示该习惯尚未养成</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.父は最近散歩をするようになった。</span><br><span class="line">2.父はなかなか散歩するようにならない。</span><br><span class="line">3.子供が生まれたことで、食べ物の安全を気にするようになった。(2010年真题)</span><br></pre></td></tr></table></figure><h3 id="やる／Vてやる-lt-授受、受益-gt"><a href="#やる／Vてやる-lt-授受、受益-gt" class="headerlink" title="やる／Vてやる&lt;授受、受益&gt;"></a>やる／Vてやる&lt;授受、受益&gt;</h3><p> 用法与「あげる」大体相同，表示说话人自己或自己这一方的人将物品赠与他人，或者为别人做某事。<br>★仅限于人对动植物、父母对子女、夫妻之间、兄弟姐妹之间或上对下的场合</p><h4 id="①N1はN2にN3をやる"><a href="#①N1はN2にN3をやる" class="headerlink" title="①Ｎ1はＮ2にＮ3をやる"></a>①Ｎ1はＮ2にＮ3をやる</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.花に水をやる。</span><br><span class="line">2.息子の誕生日に、ネクタイをやろうと思っている。</span><br></pre></td></tr></table></figure><h4 id="②N1はN2にVてやる"><a href="#②N1はN2にVてやる" class="headerlink" title="②Ｎ1はＮ2にＶてやる"></a>②Ｎ1はＮ2にＶてやる</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.水泳は僕が教えてやるよ。(2000年真题)</span><br><span class="line">2.私は弟のシャツを洗ってやる。(2004年真题)</span><br></pre></td></tr></table></figure><h3 id="Vるといい-lt-建议-gt"><a href="#Vるといい-lt-建议-gt" class="headerlink" title="Vるといい&lt;建议&gt;"></a>Vるといい&lt;建议&gt;</h3><p> 表示给对方所提的建议、劝别人进行那种行为之意。<br>★对年长者，上级一般使用：Ｖたらいかがですか<br>★建议不要做某事时使用： Vないほうがいい<br>汉语：~比较好；最好是~</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">１.日本語の辞書はこれを使うといい。</span><br><span class="line">２.疲れたでしょう。少し休むといいですよ。</span><br></pre></td></tr></table></figure><h3 id="Vて来る＜客体，信息的移动＞"><a href="#Vて来る＜客体，信息的移动＞" class="headerlink" title="Ｖて来る＜客体，信息的移动＞"></a>Ｖて来る＜客体，信息的移动＞</h3><p>表示物品或信息的移动是向着说话人一方进行。「が」：表示动作者，「に」：表示动作接受者。接受者是第一人称时，常常省略。</p><p>★「Ｖていく」はない<br>　　 ✖電話していく。<br>　　 ●電話する。<br>★动作者是公司这样一些场所名词时用：「から」</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">１.注文した本はもう送ってきた。</span><br><span class="line">２.会社から依頼を頼んできた。</span><br><span class="line">３.化粧品を買った客が苦情を言ってきた。</span><br></pre></td></tr></table></figure><h3 id="Vて行く-Vて来る"><a href="#Vて行く-Vて来る" class="headerlink" title="~Vて行く　Vて来る"></a>~Vて行く　Vて来る</h3><h4 id="表示事物的＜动作、变化的持续＞。"><a href="#表示事物的＜动作、变化的持续＞。" class="headerlink" title="表示事物的＜动作、变化的持续＞。"></a>表示事物的＜动作、变化的持续＞。</h4><p>①ｖてくる过去到现在（~来、~起来、一直~）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.この伝統はもう５００年も続いてきた。</span><br><span class="line">2.今まで一生懸命頑張ってきたんだから、大丈夫だ。</span><br></pre></td></tr></table></figure><p>②ｖていく现在到将来（~下去、继续~）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.今後もさらに進歩していくだろうと思う。</span><br><span class="line">2.これからも続けていきたいと思う。</span><br></pre></td></tr></table></figure><h4 id="表示事物，现象的出现或消失。"><a href="#表示事物，现象的出现或消失。" class="headerlink" title="表示事物，现象的出现或消失。"></a>表示事物，现象的出现或消失。</h4><p>①ｖてくる出现</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.赤ちゃんの歯が生えてきた。</span><br><span class="line">2.雲の間から月が出てきた。</span><br><span class="line">3.雨が降ってきた。</span><br></pre></td></tr></table></figure><p>②ｖていく消失</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.星が消えていく。</span><br><span class="line">2.習慣がなくなっていく。</span><br><span class="line">3.ボートは渦の中に沈んでいった。</span><br></pre></td></tr></table></figure><h3 id="Vる／N-につれて-につれ＜相应的变化＞"><a href="#Vる／N-につれて-につれ＜相应的变化＞" class="headerlink" title="Vる／Ｎ　につれて/につれ＜相应的变化＞"></a>Vる／Ｎ　につれて/につれ＜相应的变化＞</h3><p> 　表示随着某一事态或情况的变化和发展，相应的其他情况也随之发生变化或发展。主句常搭配「てきた」。<br>汉语：随着…、伴随着…</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.時間が経つにつれて、悲しみは薄らいできた。</span><br><span class="line">2.工業の発展につれて、大気汚染も深刻になってきた。</span><br><span class="line">3.技術が発達するにつれて、人々の暮らしは豊かになってきた。（2009年真题）</span><br></pre></td></tr></table></figure><h3 id="Vる／Nの-たびに＜同一情况的反复＞"><a href="#Vる／Nの-たびに＜同一情况的反复＞" class="headerlink" title="Vる／Ｎの　たびに＜同一情况的反复＞"></a>Vる／Ｎの　たびに＜同一情况的反复＞</h3><p>表示某种动作行为反复进行，或某种现象反复出现时所发生的情况。<br>汉语：每当…就、每次…都…</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.近所のおばさんは、会うたびに自分の子供の自慢話をする。</span><br><span class="line">2.うちの犬は、私が出かけようとするたびに、寂しそうな目で私を見る。(2013年真题)</span><br><span class="line">3.山田さんに会うたびに素敵な人だといつも思う。(2010年真题)</span><br></pre></td></tr></table></figure><h3 id="ながら-も-lt-转折-gt"><a href="#ながら-も-lt-转折-gt" class="headerlink" title="ながら(も)&lt;转折&gt;"></a>ながら(も)&lt;转折&gt;</h3><p>用于连接内容相反的两个分句，表示转折关系。从句多表示状态。<br>接续：R／A1／A2／N　+ ながら<br>汉语：虽然~，但是~</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">私は、悪いと知りながら、連絡しないで仕事を休んだ。</span><br><span class="line">体は小さいながら、なかなか力がある。</span><br><span class="line">全力を出しましたが、残念ながら、優勝できませんでした。(2007年真题)</span><br></pre></td></tr></table></figure><h3 id="Vるべきだ-べきではない-lt-义务-gt"><a href="#Vるべきだ-べきではない-lt-义务-gt" class="headerlink" title="Vるべきだ/べきではない&lt;义务&gt;"></a>Vるべきだ/べきではない&lt;义务&gt;</h3><p>表示行为规范、原则道理以及事物的本质来看，应该不应该去做<br>某事。多为说话人对一般事件发表意见，用于劝告，禁止，命令等。<br>汉语：应当……/不应当……<br>接续：する　=&gt;　すべき（するべき）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.約束は守るべきだ。そうしないと、信用を失うよ。(2008年真题)</span><br><span class="line">2.大学生はまず第一に勉強すべきだ。</span><br><span class="line">3.これからやるべきことはたくさんある。</span><br></pre></td></tr></table></figure><h3 id="だけ＜程度＞"><a href="#だけ＜程度＞" class="headerlink" title="だけ＜程度＞"></a>だけ＜程度＞</h3><p>表示按照动作主体的能力、主观愿望或客观需要的程度以及进行后项的动作。<br>汉语：尽量，尽可能；想~就~；能够~都</p><h4 id="a-V-れる-＋-だけV（同一动词）-尽量、尽可能"><a href="#a-V-れる-＋-だけV（同一动词）-尽量、尽可能" class="headerlink" title="a.V-れる　＋　だけV（同一动词）   　　尽量、尽可能"></a>a.V-れる　＋　だけV（同一动词）   　　尽量、尽可能</h4><p>将动词反复使用，表示“尽最大程度···”的意思。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.食べられるだけ食べた。</span><br><span class="line">2.頑張れるだけ頑張ってみる。</span><br></pre></td></tr></table></figure><h4 id="b-V-たい-＋-だけV（同一动词）-想-就-、-够"><a href="#b-V-たい-＋-だけV（同一动词）-想-就-、-够" class="headerlink" title="b. V-たい　＋　だけV（同一动词）　　　想~就~、~够"></a>b. V-たい　＋　だけV（同一动词）　　　想~就~、~够</h4><p>将动词反复使用，表示一直做到尽兴为止的意思。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.日曜日は寝たいだけ寝ることができる。</span><br><span class="line">2.遠慮しないで、食べたいだけ食べなさい。</span><br></pre></td></tr></table></figure><h4 id="c-A（少部分）-＋-だけV-客观需要"><a href="#c-A（少部分）-＋-だけV-客观需要" class="headerlink" title="c. A（少部分） ＋　だけV　　客观需要"></a>c. A（少部分） ＋　だけV　　客观需要</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.そうぞ、お好きなだけ召し上がってください。</span><br><span class="line">2.どうしたらお金が欲しいだけ手に入るのか。</span><br><span class="line">3.必要なだけ取りなさい。</span><br></pre></td></tr></table></figure><h3 id="Nには及ばない-lt-比较-gt"><a href="#Nには及ばない-lt-比较-gt" class="headerlink" title="Nには及ばない&lt;比较&gt;"></a>Nには及ばない&lt;比较&gt;</h3><p>表示主语所指称的事物或人在性质上或能力上比不过该名词所指称的事物或人。<br>汉语：~不及~、~比不过~<br>惯用表达：远不及：～には遠く及ばない<br>　　　　　　　　　～の足元にも及ばない</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.私がどんなに頑張っても、彼の実力には及ばない。</span><br><span class="line">2.CDは生の演奏には遠く及ばない。</span><br><span class="line">3.自動車がいくら速く走れても飛行機の足元にも及ばない。</span><br></pre></td></tr></table></figure><h3 id="Nに加えて-lt-递进、累加-gt"><a href="#Nに加えて-lt-递进、累加-gt" class="headerlink" title="Ｎに加えて&lt;递进、累加&gt;"></a>Ｎに加えて&lt;递进、累加&gt;</h3><p>表示在该事物、事件的基础上增加了别的事物或发生了别的事件。含有整个事件程度的加深的语感，主句常与「も」搭配。<br>汉语：加之…、除了…以外，还…</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.夏の低温に加えて、雨が少なかった。(1999年真题)</span><br><span class="line">2.お祭りは見る楽しさに加えて元気も与えてくれる。</span><br><span class="line">3.大雨に加えて、風まで吹いてきた。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ず-に-lt-否定性状态-gt&quot;&gt;&lt;a href=&quot;#ず-に-lt-否定性状态-gt&quot; class=&quot;headerlink&quot; title=&quot;ず(に)&amp;lt;否定性状态&amp;gt;&quot;&gt;&lt;/a&gt;ず(に)&amp;lt;否定性状态&amp;gt;&lt;/h3&gt;&lt;p&gt;「Vず(に)」是「Vないで」
      
    
    </summary>
    
      <category term="日语" scheme="https://janvia.github.io/categories/%E6%97%A5%E8%AF%AD/"/>
    
    
      <category term="语法" scheme="https://janvia.github.io/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>27单元</title>
    <link href="https://janvia.github.io/2019/04/14/27%E5%8D%95%E5%85%83/"/>
    <id>https://janvia.github.io/2019/04/14/27单元/</id>
    <published>2019-04-14T01:20:08.000Z</published>
    <updated>2019-04-14T01:59:41.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="命令句1"><a href="#命令句1" class="headerlink" title="命令句1"></a>命令句1</h3><p>表示绝对的命令，其使用范围比较窄，常用于发号施令、交通标志等，多为男性使用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.お父さんも「頑張れ。諦めるな。」って言ってるわよ。</span><br><span class="line">2.あそこに、「スピードを落とせ。」と書いてあります。</span><br><span class="line">3.危ないから部屋の中でボールを投げるのはやめろ。</span><br></pre></td></tr></table></figure><h3 id="V-Rなさい＜命令・敬体＞"><a href="#V-Rなさい＜命令・敬体＞" class="headerlink" title="Ｖ-Rなさい＜命令・敬体＞"></a>Ｖ-Rなさい＜命令・敬体＞</h3><p>接续：动词第一连用形+なさい<br>       一般用于大人对小孩，老师对学生，上级对下级，或者亲密关系者间。语气比动词命令形较缓和。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">もっとゆっくり食べなさい。</span><br><span class="line">早く学校に行きなさい。</span><br></pre></td></tr></table></figure><p>★更为客气的命令：お・ご~なさい</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">薬をお飲みなさい。</span><br><span class="line">この本をお読みなさい。</span><br></pre></td></tr></table></figure><p>★口语简化为「Ｖな」,语气不太客气，用于关系非常亲密的人之间</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">早く起きな。</span><br><span class="line">早く来な。</span><br></pre></td></tr></table></figure><h3 id="命令句3"><a href="#命令句3" class="headerlink" title="命令句3"></a>命令句3</h3><p>★「テ形」也可以表达命令，用于上下级和亲密者之间。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">１.ここに座って。</span><br><span class="line">２.これを持って。</span><br></pre></td></tr></table></figure><p>Ｖてくれ　　也是一种命令式，</p><pre><code> 教えてくれ～ 出てくれ～</code></pre><h3 id="Vる＋な＜动词禁止形＞"><a href="#Vる＋な＜动词禁止形＞" class="headerlink" title="Vる＋な＜动词禁止形＞"></a>Vる＋な＜动词禁止形＞</h3><p>接续：动词基本型+な<br>        这种形式也可以说就是动词简体命令形的否定形式，用于表示要求对方不要做某一行为动作。多为男性使用。<br>汉语翻译：不要~、别~</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）そんなつまらないことを人に頼むな。</span><br><span class="line">2）タバコを吸うな。</span><br><span class="line">3）ここに車を止めるな。</span><br></pre></td></tr></table></figure><h3 id="Vて来る＜客体，信息的移动＞"><a href="#Vて来る＜客体，信息的移动＞" class="headerlink" title="Ｖて来る＜客体，信息的移动＞"></a>Ｖて来る＜客体，信息的移动＞</h3><p>表示物品或信息的移动是向着说话人一方进行。「が」：表示动作者，「に」：表示动作接受者。接受者是第一人称时，常常省略。</p><p>★「Ｖていく」はない<br>　　 ✖電話していく。<br>　　 ●電話する。<br>★动作者是公司这样一些场所名词时用：「から」</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">１.注文した本はもう送ってきた。</span><br><span class="line">２.会社から依頼を頼んできた。</span><br><span class="line">３.化粧品を買った客が苦情を言ってきた。</span><br></pre></td></tr></table></figure><h3 id="Vてしまう＜完成体＞"><a href="#Vてしまう＜完成体＞" class="headerlink" title="Vてしまう＜完成体＞"></a>Vてしまう＜完成体＞</h3><p>①＜完了＞<br>强调动作的结束完成；状态的完成。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">１.この宿題をしてしまったら、遊びに行ける。</span><br><span class="line">２.もうすっかり疲れてしまって、動けない。</span><br></pre></td></tr></table></figure><p>②＜感慨消极结果＞<br>表示说话人对已结束动作的“后悔，遗憾，无法挽回弥补”的感情。<br>句尾使用过去式「Ｖてしまった」动词多为非自主动词。<br>口语：「Ｖちゃった」第二册20课2单元4.P124</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">１.急いで来たから財布を落としてしまった。(2005年真题)</span><br><span class="line">２.また授業に遅刻してしまった。</span><br></pre></td></tr></table></figure><p>③＜强行做某事的意志＞<br>表示不顾客观情况和别人的意愿，而要强行进行该动作的意志，动词多为自主动词，后项常用意志形（Ｖてしまおう・Ｖちゃおう）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.先生に言っちゃうよ。</span><br><span class="line">2.このジュース、あと少しだから、全部飲んじゃおうかな</span><br><span class="line">3.まだ帰らないの？先に帰っちゃうよ。</span><br></pre></td></tr></table></figure><h4 id="回顾对比"><a href="#回顾对比" class="headerlink" title="回顾对比"></a>回顾对比</h4><p>①Vてしまう＜强行做某事的意志＞<br>说话人不顾客观情况和他人意愿，而要强行进行某动作的意志。<br>②ましょう(か)＜意志，征求同意＞<br>说话人进行某动作的意志，含有征求对方同意的语气。(第一册P203)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A：電話しましょうか。</span><br><span class="line">B：そうですね。じゃあ、私がしましょう。</span><br><span class="line"></span><br><span class="line">　あの人は何度もメールしても返事来ないから、電話しちゃおう。</span><br></pre></td></tr></table></figure><h3 id="～がる-lt-形容词的动词化-gt"><a href="#～がる-lt-形容词的动词化-gt" class="headerlink" title="～がる&lt;形容词的动词化&gt;"></a>～がる&lt;形容词的动词化&gt;</h3><p>日语的感情、感觉形容词在句中主要用于第一人称，当要表示<br>第三人称的状态时，就在形容词的词干后面接上该后缀「がる」。变化后该词词性也从形容词变为动词。从而感情描述变为客观叙述。<br>接続：A・Ｎa+がる　<br>汉语：①感到，觉得（~心情或样子）<br>　　　②装作（~样子）<br>★Ｖたい・Ｎがほしい</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.あそこで泣いて、お菓子を欲しがっているようだ。(2011年真题)</span><br><span class="line">2.これを見たら、皆が面白がるだろうと思います。</span><br><span class="line">3.最近は数学を嫌がる子供が多いようです。</span><br><span class="line">4.弱いものに限って強がるものだ。</span><br></pre></td></tr></table></figure><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><h4 id="N1はN2より～＜比较＞"><a href="#N1はN2より～＜比较＞" class="headerlink" title="N1はN2より～＜比较＞"></a>N1はN2より～＜比较＞</h4><p>格助词より，表示比较的基准、对象。该句式表示N1比N2具有谓语所示的特征，相当于汉语“N1比N2更~”(第一册P291)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">中国は日本より広い。</span><br></pre></td></tr></table></figure><h4 id="N２よりN１のほうが～-＜比较＞"><a href="#N２よりN１のほうが～-＜比较＞" class="headerlink" title="N２よりN１のほうが～ ＜比较＞"></a>N２よりN１のほうが～ ＜比较＞</h4><p>比起N2 ，N1 更（具有某种倾向）(第一册P293)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">日本より中国のほうが広い。</span><br></pre></td></tr></table></figure><h4 id="③-N1はN２ほど～ない＜比较＞"><a href="#③-N1はN２ほど～ない＜比较＞" class="headerlink" title="③ Ｎ1はＮ２ほど～ない＜比较＞"></a>③ Ｎ1はＮ２ほど～ない＜比较＞</h4><p>副助词ほど：表示比较的基准，句尾必须接否定，<br>Ｎ1在某方面程度上不及Ｎ２<br>汉语：……不如……（程度高）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">１.日本は中国ほど広くない。</span><br><span class="line">２.今日は昨日ほど風が強くない。(2009年真题)</span><br><span class="line">３.私の部屋は姉の部屋ほど広くない。(2006年真题)</span><br></pre></td></tr></table></figure><h3 id="Nなら＜主题＞"><a href="#Nなら＜主题＞" class="headerlink" title="Ｎなら＜主题＞"></a>Ｎなら＜主题＞</h3><p>接在名词后面用于凸显主题，就对方提出的话题或者问题做出回答或是进一步加以解释说明；提出意见建议。<br>汉语：就····方面说；就····来说</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">１A：メガネはどこかな。</span><br><span class="line">　B：メガネなら、たんすの上に置いてあったよ。</span><br><span class="line">２A：もしもし、美智子さん、いらっしゃいますか</span><br><span class="line">　B：美智子ですか。</span><br><span class="line">　　　美智子なら、もう出かけましたけど。(2000年真题)</span><br></pre></td></tr></table></figure><h4 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h4><h5 id="Nなら-ば-lt-凸显，条件-gt"><a href="#Nなら-ば-lt-凸显，条件-gt" class="headerlink" title="Ｎなら(ば)&lt;凸显，条件&gt;"></a>Ｎなら(ば)&lt;凸显，条件&gt;</h5><p>接在名词后面用于凸显,强调所指的事物，表示前项是后项成立的前提，后项为说话人的判断或决定。如果该话题成立的话。<br>汉语：如果是·····的话               （第二册P115）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">風邪なら早く帰って休んだほうがいいよ。</span><br></pre></td></tr></table></figure><h5 id="は＜主题＞"><a href="#は＜主题＞" class="headerlink" title="は＜主题＞"></a>は＜主题＞</h5><p>第一册的名词谓语句与形容词谓语句中的实质都是提示主题的作用。但本册なら＜主题＞是具有“以Ｎ为话题的话”的假定意思。不可互换。(第一册P41，P98)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">①高橋は日本人だ。</span><br><span class="line">②日本語は難しい。</span><br><span class="line">③高橋は今小説を読んでいる。</span><br></pre></td></tr></table></figure><h3 id="で＜时间量的限定＞"><a href="#で＜时间量的限定＞" class="headerlink" title="で＜时间量的限定＞"></a>で＜时间量的限定＞</h3><p>接在表示时间量的名词后面时，表示对时间量的限定。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.  いろいろ考えた結果、一年で休学しました。</span><br><span class="line">2.  ３日でその仕事を仕上げた。</span><br></pre></td></tr></table></figure><p>①&lt;处所&gt;図書館で本を読む<br>②&lt;范围&gt;日本でも有名だよ。<br>③&lt;限定数量&gt;駅まで五分で行ける<br>④&lt;原材料&gt;シルクでできたドレス。<br>⑤&lt;工具手段&gt;バスで学校へ通う<br>⑥&lt;限定动作主体&gt;みんなで歌おう。<br>⑦＜动态的存在＞五階で会議がある。</p><h3 id="ず-に-lt-否定性状态-gt"><a href="#ず-に-lt-否定性状态-gt" class="headerlink" title="ず(に)&lt;否定性状态&gt;"></a>ず(に)&lt;否定性状态&gt;</h3><p>「Vず(に)」是「Vないで」的书面语形式.接续方式与ない基本相同。注意「する」变为「せず」。表示动作，状态的否定，用于中顿或并列。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">１.彼は今は1日も休まずに、まじめに働いてる。</span><br><span class="line">２.昨日は忙しくて、夜10時まで何も食べずに働いた。(2009年真题)</span><br><span class="line">３.辞書を使わずに日本語の新聞を読むことができるか。(2007年真题)</span><br></pre></td></tr></table></figure><h3 id="～Vるには＜目的＞"><a href="#～Vるには＜目的＞" class="headerlink" title="～Vるには＜目的＞"></a>～Vるには＜目的＞</h3><p>①当主句谓语动词为非自主动词时，表示要达到该目的所必须的条件，<br>②当主句谓语动词为自主动词时，表示为达到该目的所采用的手段、方法或是必须付出的努力。（结尾多使用~なければならない；～べきだ）　　<br>与「Vるために」同义、也可以使用「Ｖるためには」形式。<br>接续：动词原形</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 会議で使う資料に間違いがあったが、今から作り直すには時間が足りない。(2013年7月真题)</span><br><span class="line">2. 日本語が上手になるには一生懸命勉強しなければなりません。　</span><br><span class="line">3. 東京駅に行くには、そこの角を右に曲がったほうがいいよ。(2002年真题)</span><br></pre></td></tr></table></figure><h3 id="Vるようになる-lt-变化-gt"><a href="#Vるようになる-lt-变化-gt" class="headerlink" title="Vるようになる&lt;变化&gt;"></a>Vるようになる&lt;变化&gt;</h3><p>表示事物的变化。<br>汉语：变得可以了···；逐渐会····</p><p>a.  能力的从无到有<br>      表示获得了该能力，即由原来不具备该能力、变得开始具备该能力。否定形式「Vるようにならない」表示尚未获得该能力。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">１.私は日本語が話せるようになった。</span><br><span class="line">２.日本へ来てから、日本料理が作れるようになった。</span><br></pre></td></tr></table></figure><p>b.  现象的出现（从无到有）<br>否定形式「Vるようにならない」表示该现象尚未出现。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">１.小学校は入学したころから、だんだん風邪を引いたり熱を出したりしないようになった。(2011年真题)</span><br><span class="line">２.日本では、なかなか女性と男性が同じ条件で働けるようにならない。</span><br></pre></td></tr></table></figure><p>c.动作行为的习惯化（习惯的从无到有）<br> 否定形式「Vるようにならない」表示该习惯尚未养成</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.父は最近散歩をするようになった。</span><br><span class="line">2.父はなかなか散歩するようにならない。</span><br><span class="line">3.子供が生まれたことで、食べ物の安全を気にするようになった。(2010年真题)</span><br></pre></td></tr></table></figure><h3 id="やる／Vてやる-lt-授受、受益-gt"><a href="#やる／Vてやる-lt-授受、受益-gt" class="headerlink" title="やる／Vてやる&lt;授受、受益&gt;"></a>やる／Vてやる&lt;授受、受益&gt;</h3><p>用法与「あげる」大体相同，表示说话人自己或自己这一方的人将物品赠与他人，或者为别人做某事。<br>★仅限于人对动植物、父母对子女、夫妻之间、兄弟姐妹之间或上对下的场合<br>①Ｎ1はＮ2にＮ3をやる</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.花に水をやる。</span><br><span class="line">2.息子の誕生日に、ネクタイをやろうと思っている。</span><br></pre></td></tr></table></figure><p>②Ｎ1はＮ2にＶてやる</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.水泳は僕が教えてやるよ。(2000年真题)</span><br><span class="line">2.私は弟のシャツを洗ってやる。(2004年真题)</span><br></pre></td></tr></table></figure><h3 id="Vるといい-lt-建议-gt"><a href="#Vるといい-lt-建议-gt" class="headerlink" title="Vるといい&lt;建议&gt;"></a>Vるといい&lt;建议&gt;</h3><p>表示给对方所提的建议、劝别人进行那种行为之意。<br>★对年长者，上级一般使用：Ｖたらいかがですか<br>★建议不要做某事时使用： Vないほうがいい<br>汉语：~比较好；最好是~</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">１.日本語の辞書はこれを使うといい。</span><br><span class="line">２.疲れたでしょう。少し休むといいですよ。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;命令句1&quot;&gt;&lt;a href=&quot;#命令句1&quot; class=&quot;headerlink&quot; title=&quot;命令句1&quot;&gt;&lt;/a&gt;命令句1&lt;/h3&gt;&lt;p&gt;表示绝对的命令，其使用范围比较窄，常用于发号施令、交通标志等，多为男性使用。&lt;/p&gt;
&lt;figure class=&quot;high
      
    
    </summary>
    
      <category term="日语" scheme="https://janvia.github.io/categories/%E6%97%A5%E8%AF%AD/"/>
    
    
      <category term="语法" scheme="https://janvia.github.io/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>26单元</title>
    <link href="https://janvia.github.io/2019/03/26/26%E5%8D%95%E5%85%83/"/>
    <id>https://janvia.github.io/2019/03/26/26单元/</id>
    <published>2019-03-26T11:51:37.000Z</published>
    <updated>2019-03-26T11:57:35.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="～ような気（感じ）がする"><a href="#～ような気（感じ）がする" class="headerlink" title="～ような気（感じ）がする"></a>～ような気（感じ）がする</h3><p>用于表示说话人的某种感觉。<br>接续： 句子的简体形     名词＋の　<br>翻译：觉得……；好像……；放佛……</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.あの人とどこかで会ったような気がする。</span><br><span class="line">2.何となく不吉なことが起こるような気がする。</span><br></pre></td></tr></table></figure><h3 id="N次第だ＜决定性的事物＞"><a href="#N次第だ＜决定性的事物＞" class="headerlink" title="Ｎ次第だ＜决定性的事物＞"></a>Ｎ次第だ＜决定性的事物＞</h3><p>表示事物发展的结果取决于该名词所表示的情况或状态。<br>翻译：全凭……；全看……；视……而定</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.万事はきみの決心次第だ。</span><br><span class="line">2.宝くじに当たるかどうかは運次第だ。</span><br><span class="line">3.結婚した相手次第で人生が決まってしまうこともある。</span><br></pre></td></tr></table></figure><h3 id="使动句（使役句）"><a href="#使动句（使役句）" class="headerlink" title="使动句（使役句）"></a>使动句（使役句）</h3><p>a.他动词使动句<br>主语は/が　使动对象に　Ｎを　Vせる(他动词)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">１.主动句：子供がご飯を食べる。    </span><br><span class="line">　使动句：母  は子供にご飯を食べさせる。</span><br><span class="line"></span><br><span class="line">２.主动句：学生はテープを聞く。</span><br><span class="line">　使动句：先生は学生にテープを聞かせる。</span><br><span class="line"></span><br><span class="line">3.主动句：お皿を洗ったり、部屋を掃除したりする。 </span><br><span class="line">  使动句：お皿を洗わせたり、部屋を掃除させたリする。</span><br></pre></td></tr></table></figure><p>b.自动词使动句</p><p>​    主语A   は/が　使动对象Bに/を　Vせる(自动词)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">主动句：子供がアメリカに行く</span><br><span class="line"> 使役句：</span><br><span class="line">b-1両親 が  子供 に　アメリカに行かせる</span><br><span class="line">b-2両親 が  子供 を　アメリカに行かせる</span><br></pre></td></tr></table></figure><p>に：表示该动作是尊重使役对象B的意愿而进行的<br>を：与使役对象B的意愿无关，强调是使役者A的意思</p><p>b.自动词使动句</p><p>​          主语Aは/が　使动对象Bに/を　Vせる(自动词)</p><p>※如果原句中已经有「を」就只能用「に」为避免重复，这时，和是否是遵照使役对象B的意愿无关。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">主动句：学生たち が  走りました。</span><br><span class="line">使役句：先生  が  学生たち  に/を　走らせました。</span><br><span class="line"></span><br><span class="line">主动句：学生たち が  運動場 を 走りました。　　　　</span><br><span class="line">使役句：先生 は 学生たち に　運動場を走らせました。</span><br></pre></td></tr></table></figure><p>c.由使动态构成的请求句（敬语）,表示说话人以询问的口吻，请求对方应许我想做的事情。<br>    请让我……、请允许我……<br>Ｖさせてもらう/いただく<br>Ｖさせてくれる/くださる</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 早く帰ってもいいですか。</span><br><span class="line">→早く帰らせてもらえませんか。</span><br><span class="line"></span><br><span class="line">2ちょっと休んでもいいですか。</span><br><span class="line">→ちょっと休ませてくださいませんか。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;～ような気（感じ）がする&quot;&gt;&lt;a href=&quot;#～ような気（感じ）がする&quot; class=&quot;headerlink&quot; title=&quot;～ような気（感じ）がする&quot;&gt;&lt;/a&gt;～ような気（感じ）がする&lt;/h3&gt;&lt;p&gt;用于表示说话人的某种感觉。&lt;br&gt;接续： 句子的简体形   
      
    
    </summary>
    
      <category term="日语" scheme="https://janvia.github.io/categories/%E6%97%A5%E8%AF%AD/"/>
    
    
      <category term="语法" scheme="https://janvia.github.io/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>25单元</title>
    <link href="https://janvia.github.io/2019/03/19/25%E5%8D%95%E5%85%83/"/>
    <id>https://janvia.github.io/2019/03/19/25单元/</id>
    <published>2019-03-19T15:03:50.000Z</published>
    <updated>2019-03-19T15:11:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="V-Rながら-lt-同时-gt"><a href="#V-Rながら-lt-同时-gt" class="headerlink" title="V-Rながら&lt;同时&gt;"></a>V-Rながら&lt;同时&gt;</h3><p>表示前后两个动作同时进行或持续交替进行。其中后面的动作是主要动作。<br>翻译：一边~一边~</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 弟はいつもテレビを見ながら、宿題をしています。</span><br><span class="line">2. 音楽を聴きながら、勉強や仕事をする人のことを「ながら族」と言う。</span><br><span class="line">3. 働きながら、学校に通う。</span><br></pre></td></tr></table></figure><h3 id="ながら"><a href="#ながら" class="headerlink" title="ながら"></a>ながら</h3><p>1.表示前后两个动作同时进行或持续交替进行。一边~一边~<br>V-Rながら</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">弟はいつもテレビを見ながら、宿題をしています。</span><br></pre></td></tr></table></figure><p>2.表示原封不动、一如既往等意思。中译时需灵活处理。<br>名词+ながら</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">皮ながら食べる。</span><br><span class="line">生まれながらの音楽家</span><br></pre></td></tr></table></figure><p>3.表示前后事项相互矛盾。虽然~但是~<br>名词+  二类形容词词干+    一类形容词基本形  V-Rながら</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">知っていながら、何も教えてくれない。</span><br></pre></td></tr></table></figure><h3 id="ようだ-lt-推测-gt-：大概-吧、好像"><a href="#ようだ-lt-推测-gt-：大概-吧、好像" class="headerlink" title="~ようだ&lt;推测&gt; ：大概~吧、好像~"></a>~ようだ&lt;推测&gt; ：大概~吧、好像~</h3><p>接续：连体形<br>表示说话人根据自己的印象或感觉对事物作出的推测。 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 体がだるいんです。風邪を引いてしまったようです。</span><br><span class="line">2. 明日は雨のようです。</span><br><span class="line">3. あの声は、誰かが外で喧嘩しているようだ。</span><br></pre></td></tr></table></figure><p>このお風呂、温そうだね。　　　そうだ：第一印象，直觉<br>このお風呂、温いようだね。　　ようだ：感觉，思维（有依据）</p><h3 id="「らしい」「ようだ」「そうだ」"><a href="#「らしい」「ようだ」「そうだ」" class="headerlink" title="「らしい」「ようだ」「そうだ」"></a>「らしい」「ようだ」「そうだ」</h3><p>「ようだ」   自己所见，所体验。表示说话人的判断意见。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">天気図を見て、  あすは雨が降るようだ</span><br></pre></td></tr></table></figure><p>「そうだ」  多表示自己所见。表示某种状况，眼看就要发生，看起来要发生。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">急に暗くなった空を見て、 今にも雨が降りそうだ</span><br></pre></td></tr></table></figure><p>「らしい」 听说、通过书、媒体等间接得到。确信度高（有依据）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">天気予報を見た人から聞いて、明日は雨が降るらしいよ</span><br></pre></td></tr></table></figure><p>雨が降るそうだ。　　传闻</p><p>まるで夢のようだ　　比喻</p><h3 id="Vたばかりだ-lt-刚刚-gt-：刚-不久"><a href="#Vたばかりだ-lt-刚刚-gt-：刚-不久" class="headerlink" title="Vたばかりだ&lt;刚刚&gt; ：刚~不久"></a>Vたばかりだ&lt;刚刚&gt; ：刚~不久</h3><p>表示动作完成或某事情发生后时间不太长。（主观判断）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.その言葉は習ったばかりで、まだ上手に使えません。</span><br><span class="line">2.あの頃は、私は北京に来たばかりで、中国語もあまり分からなくて…</span><br></pre></td></tr></table></figure><h3 id="たところだ・たばかりだ"><a href="#たところだ・たばかりだ" class="headerlink" title="たところだ・たばかりだ"></a>たところだ・たばかりだ</h3><p>不同点：<br>（1）たところだ一般不直接接在明确表示过去某时间的词语后面。<br>先週、結婚したばかりだ（ところだ？）。</p><p>（2）たばかりだ可以表示动作行为结束后经过了较长一段时间的事态；与此相反，たところだ一般用于表示动作结束后经过的时间较短的事态。<br>あの二人は去年結婚したばかりだ（ところだｘ）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;V-Rながら-lt-同时-gt&quot;&gt;&lt;a href=&quot;#V-Rながら-lt-同时-gt&quot; class=&quot;headerlink&quot; title=&quot;V-Rながら&amp;lt;同时&amp;gt;&quot;&gt;&lt;/a&gt;V-Rながら&amp;lt;同时&amp;gt;&lt;/h3&gt;&lt;p&gt;表示前后两个动作同时进行或持续交
      
    
    </summary>
    
      <category term="日语" scheme="https://janvia.github.io/categories/%E6%97%A5%E8%AF%AD/"/>
    
    
      <category term="语法" scheme="https://janvia.github.io/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>24单元</title>
    <link href="https://janvia.github.io/2019/03/13/24%E5%8D%95%E5%85%83/"/>
    <id>https://janvia.github.io/2019/03/13/24单元/</id>
    <published>2019-03-13T06:06:04.000Z</published>
    <updated>2019-03-18T00:27:15.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="被动态"><a href="#被动态" class="headerlink" title="被动态"></a>被动态</h3><p>定义：以中心动词的行为者以外的非积极参与者为主语进行描写的句式叫做被动态。多伴有受到危害、损害、伤害之意，但在现代日语中，主体受益、中立（既非受害也非受益）、间接受到影响时也常用被动句式来表示。</p><p> 1类动词：将词尾う段假名    =&gt;   あ段假名 + れる<br>               書く　　　=&gt;         書かれる</p><p> 2类动词：去掉词尾 る   +  られる<br>　　　　 食べる　　  =&gt;　        食べられる</p><p> 3类动词：来（く）る　      来（こ）られる　<br>   　　　 する　　　　  =&gt;         される</p><h3 id="被动句"><a href="#被动句" class="headerlink" title="被动句"></a>被动句</h3><p>日语被动句根据其意义和句子结构的特点可以分为三类：<br>A  直接被动句       B  物主被动句       C  间接被动句</p><h3 id="直接被动句"><a href="#直接被动句" class="headerlink" title="直接被动句"></a>直接被动句</h3><h4 id="（人物）N1は-が-N2-人-にV-ら-れる"><a href="#（人物）N1は-が-N2-人-にV-ら-れる" class="headerlink" title="（人物）N1は/が  N2 (人)にＶ(ら)れる"></a>（人物）N1は/が  N2 (人)にＶ(ら)れる</h4><p>主语一般为表人的名词，谓语动词为他动词  受到~，被~</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1　母が子供を叱る。</span><br><span class="line">→子供が母に叱られる。</span><br><span class="line"></span><br><span class="line">２　犬はおばあさんを噛んだ。（噛む：かむ０）</span><br><span class="line">→おばあさんは犬に噛まれた。</span><br></pre></td></tr></table></figure><h4 id="N1-物-は-が-N2-人-にV-ら-れる"><a href="#N1-物-は-が-N2-人-にV-ら-れる" class="headerlink" title="N1(物)は/が  N2(人)にＶ(ら)れる"></a>N1(物)は/が  N2(人)にＶ(ら)れる</h4><p> 主语一般为事物性名词，动作的主体一般为非特定的个人（某一不确定的人的群体），有时会省略，多用于客观的描述某一现象。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">１.この本は多くの人に読まれている。</span><br><span class="line">２.きのう、駅前のデパートでネックレスが盗まれた。</span><br><span class="line">３.日本語能力試験は７月３日に行われる。</span><br></pre></td></tr></table></figure><h4 id="N1-物・こと-は-がN2-人-によってV-ら-れる"><a href="#N1-物・こと-は-がN2-人-によってV-ら-れる" class="headerlink" title="N1(物・こと)は/がN2(人)によってＶ(ら)れる"></a>N1(物・こと)は/がN2(人)によってＶ(ら)れる</h4><p>主语：事物名词<br>谓语是表示发明、创造、创作或发现一类（作る、発明する、設計する、書く）的动词，<br>动作主体用によって表示。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">１.この建物は有名な建築家によって設計された。</span><br><span class="line">２.この製品はイギリス人のデザイナーによって作られた。</span><br></pre></td></tr></table></figure><h4 id="N1-人-は-が-N2-人-に-から-N3-こと・もの-をV-ら-れる"><a href="#N1-人-は-が-N2-人-に-から-N3-こと・もの-をV-ら-れる" class="headerlink" title="N1(人)は/が (N2(人)に/から)N3(こと・もの)をＶ(ら)れる"></a>N1(人)は/が (N2(人)に/から)N3(こと・もの)をＶ(ら)れる</h4><p>原动作主体充当补语，有时省略；原动作客体不变。<br>一般为表示语言行为或感情、态度的他动词。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">１.友達が私に将来の仕事について相談した。</span><br><span class="line">→友達に将来の仕事について相談された。</span><br><span class="line"></span><br><span class="line">２.周りの人が反対した。</span><br><span class="line">→周りの人に反対されても、自分がどうしたいかということ</span><br><span class="line">  が一番大事だと思う。</span><br></pre></td></tr></table></figure><h3 id="物主被动句"><a href="#物主被动句" class="headerlink" title="物主被动句"></a>物主被动句</h3><h3 id="N1-所有者-は-が-N2に-N3を-V（ら）れる"><a href="#N1-所有者-は-が-N2に-N3を-V（ら）れる" class="headerlink" title="N1(所有者)は/が  N2に N3を　Ｖ（ら）れる"></a>N1(所有者)は/が  N2に N3を　Ｖ（ら）れる</h3><p> 某事物的拥有者在被动句里做主语，而该事物在被动句里仍然充当宾语。这种被动句通常明显地表现出受害的意识。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">１.　弟は私のパソコンを壊しました。</span><br><span class="line">→私は弟にパソコンを壊されました。</span><br><span class="line"></span><br><span class="line">２.　私は電車の中で（男の人に）足を踏まれました。</span><br></pre></td></tr></table></figure><h3 id="间接被动句"><a href="#间接被动句" class="headerlink" title="间接被动句"></a>间接被动句</h3><h4 id="N1-人-は-が-N2に-N3を-V-ら-れる"><a href="#N1-人-は-が-N2に-N3を-V-ら-れる" class="headerlink" title="N1(人)は/が N2に (N3を)Ｖ(ら)れる"></a>N1(人)は/が N2に (N3を)Ｖ(ら)れる</h4><p>间接被动句中做主语的一般是在原主动句不曾出现的名词，谓语动词多为自动词，表示某一事态的发生间接地给另一方（多为说话人）带来了不良的影响或损害。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a.自动词作谓语</span><br><span class="line">１.   3年前に母親が死んだ。</span><br><span class="line">        →彼は3年前に母親に死なれた。</span><br><span class="line">２.    遠足の日に、雨に降られて困った。</span><br><span class="line"></span><br><span class="line">b.他动词作谓语</span><br><span class="line">１.     一年生が先に運動場を占領した。</span><br><span class="line">         →私たちは一年生に運動場を占領された。</span><br><span class="line">２.     レストランで、隣のテーブルの人にタバコを吸われて、気   </span><br><span class="line">          分が悪くなった。</span><br></pre></td></tr></table></figure><h3 id="没有被动形式的动词"><a href="#没有被动形式的动词" class="headerlink" title="没有被动形式的动词"></a>没有被动形式的动词</h3><p>1、表示能力的动词（できる、わかる等）及动词的可能态。<br>2、状态动词。（ある、いる等）<br>3、本身含有被动意义的动词.(見つける、捕まる、教わる等)<br>4、含有自发意义的动词。（聞こえる、見える、等）</p><h3 id="Nをきっかけに-して-lt-契机-gt"><a href="#Nをきっかけに-して-lt-契机-gt" class="headerlink" title="Ｎをきっかけに(して)&lt;契机&gt;"></a>Ｎをきっかけに(して)&lt;契机&gt;</h3><p>表示以某事为机会、线索、契机等，后项发生前所未有的重大转折。<br>汉语 ：以…为契机、以…为开端<br>★：其他形式：～がきっかけで<br>　　　　　　　～がきっかけになって</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.姉は結婚をきっかけに、仕事をやめた。</span><br><span class="line">2.恵まれない子供たちの姿を見たのがきっかけで、この支援活動を始めたのです。(2008年真题)</span><br></pre></td></tr></table></figure><h3 id="らしい-lt-传闻、推测-gt"><a href="#らしい-lt-传闻、推测-gt" class="headerlink" title="らしい&lt;传闻、推测&gt;"></a>らしい&lt;传闻、推测&gt;</h3><p>表示间接的传闻或有客观依据的推测，说话人对所述内容的确信程度相当高。程度比「ようだ」更可靠。<br>接续： A1、Ｖ连体形   A2+、N+<br>汉语：似乎、好像</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.天気予報によると明日は雨らしい。</span><br><span class="line">2.二人は来年結婚するらしい。(2007年真题)</span><br><span class="line">3.彼は自分で会社を作るらしい。</span><br><span class="line">4.明日はいい天気らしい。(2002年真题)</span><br></pre></td></tr></table></figure><h3 id="ところだ"><a href="#ところだ" class="headerlink" title="ところだ"></a>ところだ</h3><p>作为形式名词接在动词的肯定简体形式后，表示动作所处的阶段。</p><h4 id="a-Vるところだ：正要…、刚要…"><a href="#a-Vるところだ：正要…、刚要…" class="headerlink" title="a.　Vるところだ：正要…、刚要…"></a>a.　Vるところだ：正要…、刚要…</h4><p>表示该动作行为在说话时即将开始进行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">１.　今、出かけるところだ。</span><br><span class="line">２.　ご飯を食べに行くところだ。</span><br></pre></td></tr></table></figure><h4 id="b-Vているところだ：现在正在…"><a href="#b-Vているところだ：现在正在…" class="headerlink" title="b.　Vているところだ：现在正在…"></a>b.　Vているところだ：现在正在…</h4><p>表示该动作行为在说话时正在进行中</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">１.　彼女は今ギョーザを作っているところだ。</span><br><span class="line">２.　私はちょうどお風呂に入っているところだ。</span><br></pre></td></tr></table></figure><h4 id="c-Vたところだ：刚刚…、刚…完"><a href="#c-Vたところだ：刚刚…、刚…完" class="headerlink" title="c.　Vたところだ：刚刚…、刚…完"></a>c.　Vたところだ：刚刚…、刚…完</h4><p>表示该动作行为在说话时刚刚结束。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">１.　授業が終わったところだ。</span><br><span class="line">２.　私が病院に駆けつけたとき、彼女は息を吹き返したところでした。</span><br></pre></td></tr></table></figure><h4 id="d-Vていたところだ"><a href="#d-Vていたところだ" class="headerlink" title="d.　Vていたところだ"></a>d.　Vていたところだ</h4><p>表示从过去某一时点到说话之前该状态一直在持续。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">１.　なかなか連絡がないから心配していたところだ。</span><br><span class="line">２.　休もうかどうしようかと考えていたところだ。</span><br></pre></td></tr></table></figure><h4 id="Vるところだ・Vるところだった"><a href="#Vるところだ・Vるところだった" class="headerlink" title="Ｖるところだ・Ｖるところだった"></a>Ｖるところだ・Ｖるところだった</h4><p>Vるところだ：正要…、刚要…<br>表示该动作行为在说话时即将开始进行</p><p>Ｖるところだった<br>表示某情况险些发生，多用于庆幸、懊恼、遗憾等的情绪表现，相当于：差一点儿······；险些······</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">車道を歩いたので、もう少しでひき殺されるところだった。</span><br></pre></td></tr></table></figure><h3 id="やすい-にくい"><a href="#やすい-にくい" class="headerlink" title="やすい/にくい"></a>やすい/にくい</h3><h4 id="a-V-R＋やすい"><a href="#a-V-R＋やすい" class="headerlink" title="a.V-R＋やすい"></a>a.V-R＋やすい</h4><p>表示该动作很容易做，该事情很容易发生。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">１.　その町は物価も安く、人も親切で住みやすいところです。</span><br><span class="line">２.　彼は太りやすい体質なので、食べ過ぎないようにしているそうだ。</span><br></pre></td></tr></table></figure><h4 id="b-V-R＋にくい"><a href="#b-V-R＋にくい" class="headerlink" title="b. V-R＋にくい"></a>b. V-R＋にくい</h4><p>表示该动作很困难，轻易做不到的意思。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">１.　これはちょっと言いにくい話なんですが。</span><br><span class="line">２.　砂利道はハイヒールでは歩きにくい。</span><br></pre></td></tr></table></figure><h3 id="～ば～ほど：越…越…"><a href="#～ば～ほど：越…越…" class="headerlink" title="～ば～ほど：越…越…"></a>～ば～ほど：越…越…</h3><p>接续:  Nなら/であれば，(名词で)ある＋ほど<br>           Na ならば/であれば， Naな/である＋ほど<br>           A-ければ， A-い＋ほど<br>           V-ば＋，V‐る＋ほど</p><p>表示随着前句所述的动作、行为或性质状态的发展变化，主句所述的性质状态就越典型或随之发生相应的变化。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.　厳しい時代であればあるほど、自分を磨くのができるんだ。</span><br><span class="line">2.　子供は元気であれば元気なほどいいです。</span><br><span class="line">3.　給料は高ければ高いほどいいです。</span><br><span class="line">4.　会話は練習すれば(練習)するほど上手になります。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;被动态&quot;&gt;&lt;a href=&quot;#被动态&quot; class=&quot;headerlink&quot; title=&quot;被动态&quot;&gt;&lt;/a&gt;被动态&lt;/h3&gt;&lt;p&gt;定义：以中心动词的行为者以外的非积极参与者为主语进行描写的句式叫做被动态。多伴有受到危害、损害、伤害之意，但在现代日语中，主体受益、
      
    
    </summary>
    
      <category term="日语" scheme="https://janvia.github.io/categories/%E6%97%A5%E8%AF%AD/"/>
    
    
      <category term="语法" scheme="https://janvia.github.io/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>hexo加速</title>
    <link href="https://janvia.github.io/2019/03/12/hexo%E5%8A%A0%E9%80%9F/"/>
    <id>https://janvia.github.io/2019/03/12/hexo加速/</id>
    <published>2019-03-12T09:13:01.000Z</published>
    <updated>2024-03-20T14:51:04.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h4><p>以阿里云域名为例，可选择10块以内的<br>网址为：</p><p><a href="https://wanwang.aliyun.com/?spm=5176.28508143.J_4VYgf18xNlTAyFFbOuOQe.308.62eb154a0Ec27i&amp;scm=20140722.X_data-f6e54ce8c5180a496ee6._.V_1" target="_blank" rel="noopener">https://wanwang.aliyun.com/?spm=5176.28508143.J_4VYgf18xNlTAyFFbOuOQe.308.62eb154a0Ec27i&amp;scm=20140722.X_data-f6e54ce8c5180a496ee6._.V_1</a></p><p>注意：域名可能需要备案，不过阿里云目前需要购买服务器才能备案，由于我只个人使用，不需要被百度到，所以猜测占时不用备案</p><h4 id="使用CLOUD的DNS服务"><a href="#使用CLOUD的DNS服务" class="headerlink" title="使用CLOUD的DNS服务"></a>使用CLOUD的DNS服务</h4><p>网址为：<a href="https://dash.cloudflare.com/" target="_blank" rel="noopener">https://dash.cloudflare.com/</a></p><p>登录后选择： Workers &amp; Pages -&gt; overview -&gt; create application ,创建个人博客 （可能可以不创建，我没找到直接设置DNS的入口）</p><p>点击：websites -&gt; add a site -&gt; 填写自己的域名 -&gt; 添加DNS配置</p><p>A       janvia.fun    76.223.126.88                Proxied    Auto<br>CNAME   www           cname-china.vercel-dns.com   DNS only   Auto</p><p>配置完成后可以看到分配给自己的DNS服务器，记录下来，然后在阿里云上修改<br>guss.ns.cloudflare.com<br>monika.ns.cloudflare.com</p><h4 id="修改DNS服务器"><a href="#修改DNS服务器" class="headerlink" title="修改DNS服务器"></a>修改DNS服务器</h4><p>在阿里云网页左上角<br>点击： 域名 -&gt; 域名列表 -&gt; janvia.fun(自己的域名) -&gt; 基本信息 -&gt; 修改DNS</p><p>将阿里云提供的DNS服务器更改为CLOUD提供的服务器，即：</p><p>dns13.hichina.com<br>dns14.hichina.com</p><p>修改为</p><p>guss.ns.cloudflare.com<br>monika.ns.cloudflare.com</p><p>修改完成后，可以通过点击：左上角 -&gt; 云解析DNS -&gt; DNS服务器地址 ，进行查看<br>修改成功则显示为：</p><p>当前DNS                         云解析系统分配DNS<br>monika.ns.cloudflare.com     dns13.hichina.com<br>guss.ns.cloudflare.com         dns14.hichina.com</p><h4 id="在牛河上添加自定义域名"><a href="#在牛河上添加自定义域名" class="headerlink" title="在牛河上添加自定义域名"></a>在牛河上添加自定义域名</h4><p>打开博客项目 -&gt; domain -&gt; add</p><p>填入买的域名 janvia.fun</p><p>选择第一个，将生成www.janvia.fun和janvia.fun,由于DNS配置已经配置了@和www，所以不需要在这里设置重定向，所以删除janvia.fun<br>（实际测试，如果不删除，网址输入janvia.fun，将一直重定向而导致无法访问）</p><h4 id="hexo配置"><a href="#hexo配置" class="headerlink" title="hexo配置"></a>hexo配置</h4><p>hexo项目下的CNAME中填入买的域名：</p><p>janvia.fun<br>www.janvia.fun</p><p>不设置重定向</p><h4 id="cloudflare配置（可选）"><a href="#cloudflare配置（可选）" class="headerlink" title="cloudflare配置（可选）"></a>cloudflare配置（可选）</h4><p>点击website,选择自己的域名 ，进入配置页面</p><h5 id="SSL-TCL"><a href="#SSL-TCL" class="headerlink" title="SSL/TCL"></a>SSL/TCL</h5><p>1.在overview页面</p><ul><li>设置成full(strict) ,否则janvia.fun由于重定向过多无法访问</li></ul><p>2.在Eage Certificates页面</p><ul><li>打开Always use https</li><li>Minimum TLS Version设置成1.1</li><li>Opportunistic Encryption 打开</li></ul><p>3.在Origin Server页面</p><ul><li>Authenticated Origin Pulls 打开</li></ul><h5 id="Speed-optimization"><a href="#Speed-optimization" class="headerlink" title="Speed/optimization"></a>Speed/optimization</h5><p>1.在content optimization 页面</p><ul><li>Brotli 打开</li><li>Rocket Loader 打开</li><li>Auto Minify ，全选</li></ul><p>2.Other页面</p><ul><li>AMP Real URL 打开</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;购买域名&quot;&gt;&lt;a href=&quot;#购买域名&quot; class=&quot;headerlink&quot; title=&quot;购买域名&quot;&gt;&lt;/a&gt;购买域名&lt;/h4&gt;&lt;p&gt;以阿里云域名为例，可选择10块以内的&lt;br&gt;网址为：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://wanwang.ali
      
    
    </summary>
    
      <category term="工具" scheme="https://janvia.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="hexo" scheme="https://janvia.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
